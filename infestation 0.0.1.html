<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Infestation</title>
<style>
/* -------------------------------------------------------------
   GLOBAL LAYOUT
------------------------------------------------------------- */
body{
  margin:0;
  font-family:Arial,Helvetica,sans-serif;
  background:#111;
  color:#eee;
  overflow:hidden;
}
.screen{display:none;height:100vh;box-sizing:border-box;}
.active{display:flex;}

/* -------------------------------------------------------------
   START SCREEN
------------------------------------------------------------- */
#startScreen{
  position: relative;
  flex-direction:column;
  justify-content:center;
  align-items:center;
  background:linear-gradient(135deg,#220022,#001122);
}
#quickStartBtn {
    position: absolute;
    bottom: 1rem;
    right: 1rem;
}
#startScreen h1{font-size:3rem;margin-bottom:.5rem;}
#startScreen p{font-size:1.2rem;max-width:31.25rem;text-align:center;}
#ascii-title{
  font-family:monospace;
  font-size:.65vw;
  line-height:1.2;
  color:#00ff00;
  margin-bottom:1rem;
  text-shadow: 0.25rem 0.25rem 0.25rem #000, 0.1875rem 0.1875rem 0 #f0f, -0.1875rem -0.1875rem 0 #0ff;
}
#startBtn, #loadBtn{
  margin-top:2rem;padding:.8rem 1.6rem;font-size:1.2rem;
  background:#00ff00;color:#000;border:none;cursor:pointer;
  border-radius:.4rem;
}
#startBtn:hover{background:#33ff33;}

/* -------------------------------------------------------------
   MAIN GAME SCREEN (sidebar + main area)
------------------------------------------------------------- */
#gameScreen{flex-direction:row;}

/* ----- Sidebar (always visible) ----- */
#sidebar{
  width:18.75rem;
  background:#1a1a2d;
  padding:1rem;
  box-sizing:border-box;
  overflow-y:auto;
  position:relative;
}

/* ----- Header row (Time | Money) ----- */
#headerRow{
  display:flex;
  justify-content:space-between;
  font-size:.9rem;
}
#headerRow span{
  flex-basis: 50%;
}
#headerRow #clock{text-align:left;}
#headerRow #money{text-align:right;}

/* ----- Date Row ----- */
#dateRow #date {
  cursor: pointer;
  transition: color .15s ease;
  font-size: 1.1em;
  font-weight: bold;
}
#dateRow #date:hover {
  color: #33ff33;
}

/* ----- Character description ----- */
#charDesc{
  font-size:.85rem;
  margin-bottom:.8rem;
  color:#88ff88;
}

/* -------------------------------------------------
   NEED LAYOUT – thin full‑width bar, name & label on ONE line
   ------------------------------------------------- */

.need{
  margin-bottom:0.2rem;
  position:relative;
}

/* header that holds the combined “Name: Label” line */
.needHeader{
  display:flex;
  justify-content:center;
  margin-bottom:0.2rem;               /* space between text and bar */
}

/* the single line – we’ll fill it via JS */
.needLine{
  font-size:.85rem;
  color:#fff;                      /* name part is white */
}

/* the label part (after the colon) will be coloured by JS */
.needLine .stage{
  color:#ccc;                      /* fallback colour */
}

/* thin, sharp‑edge bar */
.bar{
  width:100%;
  height:0.375rem;                      /* thin rectangle */
  background:#444;
  overflow:hidden;
}

/* coloured fill – colour set by JS */
.fill{
  height:100%;
  display:block;
}

/* -------------------------------------------------
   HIDDEN (“bad”) needs – show only the stage label
   ------------------------------------------------- */
.noName .needLine{
  /* show the line (previously hidden) */
  display:flex;               /* keep flex so the label aligns nicely */
  justify-content:center;
  margin-left:0.2rem;         /* tiny indent so it lines up with other lines */
}

/* the stage label inside a hidden need – colour will be set by JS */
.noName .needLine .stage{
  /* fallback colour – will be overridden */
  color:#aaa;
}

/* -------------------------------------------------
   TOOLTIP (shows name in white + % in bar colour)
   ------------------------------------------------- */
.tooltip{
  position:absolute;
  left:50%;
  bottom:120%;
  transform:translateX(-50%);
  padding:.3rem .5rem;
  background:#222;
  color:#fff;
  font-size:.75rem;
  white-space:nowrap;
  border-radius:0.1875rem;
  opacity:0;
  pointer-events:none;
  transition:opacity .15s ease;
  z-index:10;
}
.tooltip::after{
  content:"";
  position:absolute;
  top:100%;
  left:50%;
  transform:translateX(-50%);
  border-width:0.3125rem 0.3125rem 0 0.3125rem;
  border-style:solid;
  border-color:#222 transparent transparent transparent;
}
.need:hover .tooltip{
  opacity:1;
}

/* ---- Bottom button bar – each button on its own row, full width ---- */
#bottomButtons{
  display:flex;
  flex-direction:column;          /* stack vertically */
  gap:.4rem;
  position:absolute;
  bottom:1rem;
  width:calc(100% - 2rem);        /* parent padding is 1rem on each side */
}

/* generic button – fills the whole row */
.bottomBtn{
  flex:1 0 auto;                  /* take full width of its row */
  width:100%;
  padding:.4rem .6rem;
  box-sizing:border-box;

  /* NEW – visual styling */
  background:#444;                /* dark‑gray background (feel free to adjust) */
  color:#fff;                     /* white text for contrast */
  border:0.125rem solid transparent;   /* invisible border so the button size doesn’t jump on hover */
  border-radius:0.25rem;              /* optional rounded corners */
  transition:border-color .15s ease, background .15s ease; /* smooth hover effect */
}

/* Hover state – green border */
.bottomBtn:hover{
  background:#555;                /* a slightly lighter gray while hovered (optional) */
  border-color:#00ff00;           /* bright green border on hover */
}
/* -----------------------------------------------------------------
   OVERLAY BUTTON STYLE – independent from the global style
   ----------------------------------------------------------------- */
.overlayBtn{
  /* Reset anything that the global .bottomBtn forced */
  width:auto !important;          /* ignore the global width:100% */
  flex:0 1 auto;                  /* allow shrinking, no forced growth */
  display:inline-block;           /* size to its intrinsic content */
  padding:.3rem .25rem;           /* comfortable click/tap area */
  margin:0;                       /* tiny gap between neighbour elements */
  min-width:0;                    /* clear any inherited min‑width */
  box-sizing:border-box;          /* include padding in the width */

  /* Visuals */
  background:#222;                /* darker background than sidebar buttons */
  color:#00ff00;                  /* bright green text – matches the UI theme */
  border:0.0625rem solid #00ff00;
  border-radius:0.25rem;
}
.overlayBtn:hover{
  background:#333;
}

/* ---- Settings / Cheats when cheats are enabled ---------------------- */
/* the body gets the class “cheats-enabled” when the checkbox is ticked */
body.cheats-enabled #bottomButtons{
  flex-direction:row;             /* switch to a horizontal row */
  flex-wrap:wrap;
}

/* each takes ≈½ of the line */
body.cheats-enabled .settingsBtn,
body.cheats-enabled .cheatsBtn{
  flex:1 1 48%;                   /* half‑width, leave a tiny gap */
  width:auto;                    /* let flex control width */
}

/* keep the Settings button left‑aligned, Cheats button on the right */
body.cheats-enabled .settingsBtn{margin-right:auto;}
body.cheats-enabled .cheatsBtn{margin-left:auto;}

/* -------------------------------------------------------------
   MAIN AREA (rooms / events)
------------------------------------------------------------- */
#mainArea{
  flex:1;
  position:relative;
  padding:1.5rem;
  overflow-y:auto;
}

/* Text styles */
.eventTitle{font-size:1.8rem;margin-top:0;color:#00ff00;}
.eventText{margin:1rem 0;line-height:1.4;}
.link{color:#00ff00;cursor:pointer;text-decoration:underline;}
.link:hover{color:#33ff33;}

/* -------------------------------------------------------------
   NAVIGATION COLUMN (absolute, anchored below text)
------------------------------------------------------------- */
.navColumn{
  position:absolute;
  left:15%;
  display:flex;
  flex-direction:column;
  gap:.6rem;
}
.navColumn .link{font-size:1.1rem;}

/* -------------------------------------------------------------
   OVERLAY WINDOWS (square, 30 % of viewport width)
------------------------------------------------------------- */
.overlay{
  position:fixed;
  top:50%; left:50%;
  transform:translate(-50%,-50%);
  background:#222;
  border:0.125rem solid #00ff00;
  padding:1rem;
  width: 60rem;
  min-width: 900px;
  max-width: 1350px;
  min-height: 800px;
  max-height: 850px;
  z-index:1000;
  display:none;
  flex-direction:column;
  overflow: hidden;
}
.overlayHeader{
  font-weight:bold;
  margin-bottom:.6rem;
  color:#00ff00;
}
.overlayClose{
  position:absolute;
  top:.4rem;
  right:.6rem;
  cursor:pointer;
  color:#ff5555;
}
.overlayBody{
  margin-top:1.2rem;
  flex-grow: 1;
  min-height: 0;
  word-wrap: break-word; /* Prevent horizontal overflow from long words */
  display: flex;
  flex-direction: column;
}

#char-tab-content-wrapper, .cheat-panels-container, #journal-content-wrapper {
    flex-grow: 1;
    min-height: 0; /* Crucial for enabling scrolling in a flex child */
}

#char-buttons, .cheat-tabs-container {
    border-bottom: 1px solid #444;
    padding-bottom: 0.8rem;
    margin-bottom: 0.8rem;
}

/* CHEAT OVERLAY SPECIFIC STYLES - NEW STRATEGY */
.cheatsOverlay .overlayBody {
  display: flex;
  flex-direction: column;
  height: 43vw; /* Ensure it fills the parent's height */
  max-height: 795px;
}

.cheat-tabs-container {
  flex-shrink: 0; /* Prevent tabs from shrinking */
  display: flex;
  justify-content: center;
  gap: 0.5rem;
}

.cheat-panels-container {
  position: relative; /* For positioning panels inside */
}

.cheat-tab-content {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow-y: auto;
  padding: 0.5rem;
  box-sizing: border-box;
}

.skills-column-container {
  column-count: 2;
  column-gap: 1rem;
}

.tooltip-overlay {
  position: absolute;
  background: #2a2a3a;
  border: 0.0625rem solid #00ff00;
  padding: 0.8rem;
  width: 15.625rem;
  z-index: 1001;
  display: none;
  border-radius: 0.25rem;
  box-shadow: 0 0.3125rem 0.9375rem rgba(0,0,0,0.5);
}

/* -------------------------------------------------------------
   CALENDAR OVERLAY
------------------------------------------------------------- */
#calendar-overlay {
  width: 11vw;
  height: auto;
  min-height: 0;
  max-height: 25rem;
  min-width: 9.375rem;
  font-size: 0.8rem;
  /* top and left are now set by JS */
  transform: none;
  margin: 0;
}

#calendar-header .overlayBtn {
  padding: .2rem .5rem;
  flex-grow: 0;
}

#calendar-month-year {
  flex-grow: 1;
  text-align: center;
  font-weight: bold;
  color: #00ff00;
}

#calendar-days {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  gap: 0.25rem;
}

.calendar-day {
  background: #2a2a3a;
  border: 0.0625rem solid #444;
  height: 0;
  padding-bottom: 100%; /* Creates a square aspect ratio */
  position: relative;
  cursor: pointer;
  transition: background-color 0.15s ease, border-color 0.15s ease;
}

.calendar-day:hover {
  background: #3a3a4a;
  border-color: #00ff00;
}

.calendar-day span {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/* For days not in the current month */
.calendar-day.other-month {
  color: #666;
  background: #222;
  cursor: default;
}
.calendar-day.other-month:hover {
  background: #222;
  border-color: #444;
}

/* For the current day */
.calendar-day.current-day {
  border-color: #00ff00;
  box-shadow: 0 0 0.3125rem #00ff00;
}

/* For period days */
.calendar-day.period-day {
  box-shadow: 0 0 0 0.125rem #ff4d4d inset;
}

/* For days with a reminder */
.calendar-day.has-reminder::after {
  content: "!";
  position: absolute;
  top: 0.125rem;
  right: 0.25rem;
  color: yellow;
  font-weight: bold;
  font-size: 1.2em;
  text-shadow: 0.0625rem 0.0625rem 0.0625rem #000;
}

/* ----- Inventory Tab Styles ----- */
#char-inventory {
    /* The parent overlay has a fixed height, this allows the grid to fill it */
    height: 100%;
}
#char-equipment {
    height: 700px; /* Give the equipment tab a fixed, larger height to fit the ASCII art */
}
.inventory-grid {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    gap: 0.5rem;
    height: 100%;
    overflow-y: auto;
    padding: 1rem;
    box-sizing: border-box;
}
.inventory-item {
    border: 0.0625rem solid #444;
    padding: 0.5rem;
    text-align: center;
    cursor: pointer;
    background: #2a2a3a;
    transition: background-color 0.15s ease, border-color 0.15s ease;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    border-radius: 0.25rem; /* Added for consistency */
}
.inventory-item:hover {
    background-color: #3a3a4a;
    border-color: #00ff00;
}


/* -------------------------------------------------------------
   BOTTOM BUTTON BAR – definitions (kept for reference)
------------------------------------------------------------- */
/* (the actual buttons are now written directly in the HTML) */

/* -------------------------------------------------------------
   NOTIFICATION OVERLAY
------------------------------------------------------------- */
#error-notification-overlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: #ff0000;
  color: #fff;
  padding: 1rem 2rem;
  border-radius: 0.5rem;
  border: 0.125rem solid #000;
  box-shadow: 0 0 0.9375rem rgba(255, 0, 0, 0.5);
  z-index: 2000;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.4s ease-in-out;
  display: none;
  font-weight: bold;
  text-align: center;
}

#craft-notification-overlay {
  position: fixed;
  top: 1.875rem;
  left: 50%;
  transform: translateX(-50%);
  background: #00ff00;
  color: #000;
  padding: 0.8rem 1.5rem;
  border-radius: 0.5rem;
  border: 0.125rem solid #000;
  box-shadow: 0 0 0.9375rem rgba(0,255,0,0.5);
  z-index: 2000;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.4s ease-in-out;
  display: none;
  font-weight: bold;
  text-align: center;
}

/* -------------------------------------------------------------
   CHARACTER CREATION SCREEN
------------------------------------------------------------- */
#creationScreen {
  justify-content: center;
  align-items: center;
  background: linear-gradient(135deg,#110011,#001122);
}

.creation-container {
  width: 80vw;
  height: 80vh;
  background: #1a1a2d;
  border: 1px solid #00ff00;
  display: flex;
  flex-direction: column;
  padding: 1rem;
}

.creation-header {
  text-align: center;
  color: #00ff00;
  border-bottom: 1px solid #444;
  padding-bottom: 1rem;
  margin-bottom: 1rem;
}

.creation-main {
  display: grid;
  /* Split the layout into four columns, giving more space to the latter two */
  grid-template-columns: 0.8fr 0.8fr 1fr 1.4fr;
  flex-grow: 1;
  gap: 1rem;
  overflow: hidden;
}

.creation-column {
    padding: 1rem;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
}

.push-to-bottom {
    margin-top: auto;
}

.creation-column:not(:last-child) {
    border-right: 1px solid #444;
}

.creation-main > .creation-column:first-child {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.creation-footer {
    text-align: center;
    border-top: 1px solid #444;
    padding-top: 1rem;
    margin-top: 1rem;
}

.option-group {
  margin-bottom: 1.5rem;
}
.option-group label {
  display: block;
  margin-bottom: 0.5rem;
  color: #00ff00;
}
.option-group input[type="text"],
.option-group input[type="range"] {
  width: 100%;
}

.color-swatch-container {
  display: flex;
  gap: 0.5rem;
}

.color-swatch {
  width: 30px;
  height: 30px;
  border: 2px solid #555;
  cursor: pointer;
  border-radius: 50%;
}

.color-swatch.selected {
  border-color: #00ff00;
  box-shadow: 0 0 5px #00ff00;
}

/* -------------------------------------------------------------
   RESPONSIVE ADJUSTMENTS (optional)
------------------------------------------------------------- */
@media (max-width:37.5rem){
  #sidebar{width:100%;height:auto;}
  #gameScreen{flex-direction:column;}
}
</style>
<style>
/* Additional styles for Hex Color Picker */
.grid-picker-container {
    display: flex;
    flex-direction: column;
    align-items: center; /* Center the rows */
    margin-top: 0.5rem;
}
.grid-picker-row {
    display: flex;
    gap: 0.5rem;
    /* No vertical margin between rows to keep the grid tight */
    margin-bottom: 0;
}
.hex-picker-container {
    margin-top: 0.5rem;
    /* Use flexbox for more reliable centering of the rows */
    display: flex;
    flex-direction: column;
    align-items: center;
}

.hex-row {
    display: flex; /* A row is now a flex container for the swatches */
    justify-content: center;
    margin-bottom: -5px; /* Overlap hexagons slightly to create the honeycomb effect */
}

.hex-swatch {
    width: 20px;
    height: 23.1px; /* width * sqrt(3) / 2 * 2 */
    background-color: #888;
    position: relative;
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
    cursor: pointer;
    transition: transform 0.1s ease-out;
}

.hex-swatch:hover {
    transform: scale(1.1);
}

.hex-swatch.selected {
    transform: scale(1.25);
    z-index: 10;
    box-shadow: 0 0 8px #00ff00;
}
#grayscale-overlay {
    background: transparent;
    border: none;
    /* Allows clicks to pass through the overlay container to what's behind it */
    pointer-events: none;
}
#grayscale-overlay .hex-swatch {
    /* Re-enable pointer events for the swatches themselves */
    pointer-events: auto;
}
</style>
</head>
<body>

<!-- ==================== START SCREEN ==================== -->
<section id="startScreen" class="screen active">
  <pre id="ascii-title">
░▒▓█▓▒░▒▓███████▓▒░░▒▓████████▓▒░▒▓████████▓▒░░▒▓███████▓▒░▒▓████████▓▒░▒▓██████▓▒░▒▓████████▓▒░▒▓█▓▒░░▒▓██████▓▒░░▒▓███████▓▒░
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░         ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░      ░▒▓█▓▒░         ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓██████▓▒░ ░▒▓██████▓▒░  ░▒▓██████▓▒░   ░▒▓█▓▒░  ░▒▓████████▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░             ░▒▓█▓▒░  ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓█▓▒░             ░▒▓█▓▒░  ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░
░▒▓█▓▒░▒▓█▓▒░░▒▓█▓▒░▒▓█▓▒░      ░▒▓████████▓▒░▒▓███████▓▒░   ░▒▓█▓▒░  ░▒▓█▓▒░░▒▓█▓▒░ ░▒▓█▓▒░   ░▒▓█▓▒░░▒▓██████▓▒░░▒▓█▓▒░░▒▓█▓▒░
  </pre>
  <p>
    Maya has been unlucky enough to become host to a worm‑like alien parasite.
    Manage her physical and mental state while she tries to uncover the truth.
  </p>
  <div id="start-buttons-container" style="display: flex; gap: 1rem;">
      <button id="startBtn">Begin</button>
      <button id="loadBtn">Load Game</button>
  </div>
  <button id="quickStartBtn" class="overlayBtn">Quick Start (Debug)</button>
</section>

<!-- ==================== LOAD OVERLAY (from Start Screen) ==================== -->
<div id="loadBtn-overlay" class="overlay">
  <div class="overlayHeader">Load Game</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody"></div>
</div>

<!-- ==================== CHARACTER CREATION SCREEN ==================== -->
<section id="creationScreen" class="screen">
  <div class="creation-container">
    <div class="creation-header">
      <h2>Create Your Character</h2>
    </div>
    <div class="creation-main">
      <!-- Column 1: Height, Hair Length, Eye Color -->
      <div class="creation-column">
        <div class="option-group">
          <label for="heightSlider">Height: <span id="heightValue">170</span> cm</label>
          <input type="range" id="heightSlider" min="150" max="185" value="170">
        </div>
        <div class="option-group">
          <label for="hairLengthSlider">Hair Length: <span id="hairLengthValue">10</span> cm</label>
          <input type="range" id="hairLengthSlider" min="0" max="100" value="10">
        </div>
        <div class="option-group push-to-bottom">
            <label>Eye Color:</label>
            <div id="eye-color-picker" class="hex-picker-container"></div>
        </div>
      </div>

      <!-- Column 2: Skin Color, Hair Color -->
      <div class="creation-column">
        <div class="option-group">
            <label>Skin Color:</label>
            <div id="skin-color-picker" class="hex-picker-container"></div>
        </div>
        <div class="option-group">
            <label style="display: flex; align-items: center; gap: 0.5rem; justify-content: center;">
                <input type="checkbox" id="unnaturalColorsToggle">
                Show Unnatural Colors
            </label>
        </div>
        <div class="option-group push-to-bottom">
            <label>Hair Color:</label>
            <div id="hair-color-picker" class="hex-picker-container"></div>
        </div>
      </div>

      <!-- Column 3: Body Descriptors -->
      <div class="creation-column">
        <div class="option-group">
            <label>Body Shape:</label>
            <div id="bodyShapeOptions" style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;"></div>
        </div>
      </div>

      <!-- Column 4: Preview -->
      <div id="creation-preview" class="creation-column">
        <!-- Character preview will be generated by JS here -->
      </div>
    </div>
    <div class="creation-footer">
        <button id="finalizeBtn" class="overlayBtn">Finalize Character</button>
    </div>
  </div>
</section>

<!-- ==================== MAIN GAME SCREEN ==================== -->
<section id="gameScreen" class="screen">
  <!-- ---------- Sidebar (always visible) ---------- -->
  <aside id="sidebar">
    <h3>Game Info</h3>

    <!-- Header row: Time | Money -->
    <div id="headerRow">
      <span id="clock">09:00</span>
      <span id="money">$0.00</span>
    </div>

    <!-- Date row -->
    <div id="dateRow" style="text-align: center; margin-bottom: 1rem;">
        <span id="date"></span>
    </div>

    <!-- Character description -->
    <div id="charDesc">Wearing: lab coat, sneakers</div>

<!-- ==================== NEED CONTAINERS (NEW LAYOUT) ==================== -->

<!-- regular needs -->
<div class="need" id="need-tiredness"
     data-name="Fatigue"
     data-labels="Exhausted|Very Tired|Tired|Alert|Energized"
     data-label-ranges="10,30,60,90,100">
  <div class="needHeader">
    <span class="needLine"><!-- filled by JS --> </span>
  </div>
  <div class="bar"><span class="fill"></span></div>
  <div class="tooltip"></div>
</div>

<div class="need" id="need-stress"
     data-name="Stress"
     data-labels="Relaxed|Calm|Stressed|Very Stressed|Panicked"
     data-label-ranges="10,40,70,90,100">
  <div class="needHeader">
    <span class="needLine"></span>
  </div>
  <div class="bar"><span class="fill"></span></div>
  <div class="tooltip"></div>
</div>

<div class="need" id="need-trauma"
     data-name="Trauma"
     data-labels="Secure|Stable|Traumatized|Severely Traumatized|Shattered"
     data-label-ranges="10,30,60,90,100">
  <div class="needHeader">
    <span class="needLine"></span>
  </div>
  <div class="bar"><span class="fill"></span></div>
  <div class="tooltip"></div>
</div>

<div class="need" id="need-happiness"
     data-name="Happiness"
     data-labels="Depressed|Very Unhappy|Unhappy|Content|Joyful"
     data-label-ranges="10,30,70,90,100">
  <div class="needHeader">
    <span class="needLine"></span>
  </div>
  <div class="bar"><span class="fill"></span></div>
  <div class="tooltip"></div>
</div>

<div class="need" id="need-arousal"
     data-name="Arousal"
     data-labels="Numb|Very Low|Low|Normal|High"
     data-label-ranges="5,20,50,80,100">
  <div class="needHeader">
    <span class="needLine"></span>
  </div>
  <div class="bar"><span class="fill"></span></div>
  <div class="tooltip"></div>
</div>

<!-- hidden / “bad” needs – keep hidden until shown -->
<div class="need hiddenBar noName" id="need-corruption"
     data-name="Corruption"
     data-labels="None|Trace|Low|Medium|High"
     data-label-ranges="1,20,50,80,100">
  <div class="needHeader"><span class="needLine"></span></div>
  <div class="bar"><span class="fill"></span></div>
  <div class="tooltip"></div>
</div>

<div class="need hiddenBar noName" id="need-alcohol"
     data-name="Alcohol"
     data-labels="Sober|Buzzed|Tipsy|Drunk|Wasted"
     data-label-ranges="1,20,50,80,100">
  <div class="needHeader"><span class="needLine"></span></div>
  <div class="bar"><span class="fill"></span></div>
  <div class="tooltip"></div>
</div>

<div class="need hiddenBar noName" id="need-drugs"
     data-name="Drugs"
     data-labels="Clean|Mild|Moderate|Heavy|Overdose"
     data-label-ranges="1,20,50,80,100">
  <div class="needHeader"><span class="needLine"></span></div>
  <div class="bar"><span class="fill"></span></div>
  <div class="tooltip"></div>
</div>

    <!-- Bottom button bar (static HTML – JS will attach handlers) -->
    <div id="bottomButtons">
      <button id="btnChar"    class="bottomBtn">Character</button>
      <button id="btnSocial"  class="bottomBtn">Social</button>
      <button id="btnJournal" class="bottomBtn">Journal</button>
      <button id="btnSaves"   class="bottomBtn">Saves</button>

      <!-- Settings button – always visible -->
      <button id="btnSettings" class="bottomBtn settingsBtn">Settings</button>

      <!-- Cheats button – hidden until checkbox is ticked -->
      <button id="cheatsBtn"   class="bottomBtn cheatsBtn" style="display:none;">Cheats</button>
    </div>
  </aside>
<!-- CHARACTER overlay -->
<div id="btnChar-overlay" class="overlay">
  <div class="overlayHeader">Character</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody">
    <div id="char-buttons" style="display: flex; justify-content: space-between; gap: 0.5rem;">
        <button class="overlayBtn" style="flex-grow: 1;" onclick="showCharTab('status')">Status</button>
        <button class="overlayBtn" style="flex-grow: 1;" onclick="showCharTab('skills')">Skills</button>
        <button class="overlayBtn" style="flex-grow: 1;" onclick="showCharTab('equipment')">Equipment</button>
        <button class="overlayBtn" style="flex-grow: 1;" onclick="showCharTab('inventory')">Inventory</button>
        <button class="overlayBtn" style="flex-grow: 1;" onclick="showCharTab('stats')">Stats</button>
    </div>
    <div id="char-tab-content-wrapper" style="overflow-y: auto; min-height: 0;">
        <div id="char-status" class="char-tab"></div>
        <div id="char-skills" class="char-tab" style="display: none;"></div>
        <div id="char-stats" class="char-tab" style="display: none;"></div>
        <div id="char-equipment" class="char-tab" style="display: none;"></div>
        <div id="char-inventory" class="char-tab" style="display: none;"></div>
    </div>
  </div>
</div>


<!-- SOCIAL overlay -->
<div id="btnSocial-overlay" class="overlay">
  <div class="overlayHeader">Social</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody"></div>
</div>

<!-- JOURNAL overlay -->
<div id="btnJournal-overlay" class="overlay">
  <div class="overlayHeader">Journal</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody"></div>
</div>

<!-- SAVES overlay -->
<div id="btnSaves-overlay" class="overlay">
  <div class="overlayHeader">Saves</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody"></div>
</div>
  <!-- ---------- Main area (events / rooms) ---------- -->
  <main id="mainArea">
    <!-- Content will be injected by JavaScript -->
  </main>
</section>

<!-- SETTINGS overlay (square, 30 % of viewport width) -->
<div id="btnSettings-overlay" class="overlay settingsOverlay">
  <div class="overlayHeader">Settings</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody">
    <label style="display:flex;align-items:center;gap:.4rem;">
      <input type="checkbox" id="cheatsChk" onchange="toggleCheats(this)">
      Enable Cheats
    </label>
    <hr style="margin: 1rem 0;">
    <div style="margin-bottom: 1rem;">
      <strong>Font Family</strong>
      <div id="font-options" style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">
        <label><input type="radio" name="font" value="Arial, Helvetica, sans-serif" onchange="changeFont(this.value)"> Arial</label>
        <label><input type="radio" name="font" value="'Times New Roman', Times, serif" onchange="changeFont(this.value)"> Times New Roman</label>
        <label><input type="radio" name="font" value="'Courier New', Courier, monospace" onchange="changeFont(this.value)"> Courier New</label>
        <label><input type="radio" name="font" value="Verdana, Geneva, sans-serif" onchange="changeFont(this.value)"> Verdana</label>
      </div>
    </div>
    <div>
      <strong>Font Size</strong>
      <div id="fontsize-options" style="display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.5rem;">
        <label><input type="radio" name="fontsize" value="0.9rem" onchange="changeFontSize(this.value)"> Small</label>
        <label><input type="radio" name="fontsize" value="1rem" onchange="changeFontSize(this.value)"> Medium</label>
        <label><input type="radio" name="fontsize" value="1.2rem" onchange="changeFontSize(this.value)"> Large</label>
      </div>
    </div>
  </div>
</div>

<!-- ==================== CALENDAR OVERLAY ==================== -->
<div id="calendar-overlay" class="overlay" style="display: none;">
  <div class="overlayHeader" id="calendar-header" style="display: flex; justify-content: space-between; align-items: center;">
    <button id="calendar-prev-btn" class="overlayBtn">&lt;</button>
    <span id="calendar-month-year"></span>
    <button id="calendar-next-btn" class="overlayBtn">&gt;</button>
  </div>
  <div class="overlayBody" id="calendar-body">
    <div id="calendar-weekdays" style="display: grid; grid-template-columns: repeat(7, 1fr); text-align: center; margin-bottom: 0.5rem; font-size: 0.8em; color: #aaa;">
      <div>Sun</div>
      <div>Mon</div>
      <div>Tue</div>
      <div>Wed</div>
      <div>Thu</div>
      <div>Fri</div>
      <div>Sat</div>
    </div>
    <div id="calendar-days" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 2px;">
      <!-- Day cells will be inserted by JS -->
    </div>
  </div>
</div>

<!-- CHEATS overlay (same square size) -->
<div id="cheatsBtn-overlay" class="overlay cheatsOverlay">
  <div class="overlayHeader">Cheats</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody">
    <!-- Cheat controls will be inserted by JS later -->
  </div>
</div>

<!-- ==================== SUB-OVERLAY for item selection etc. ==================== -->
<div id="sub-overlay" class="tooltip-overlay">
  <div class="overlayHeader"></div>
  <div class="overlayClose" onclick="document.getElementById('sub-overlay').style.display='none'">✖</div>
  <div class="overlayBody"></div>
</div>

<!-- ==================== TAILOR HUB OVERLAY ==================== -->
<div id="tailor-hub-overlay" class="overlay">
  <div class="overlayHeader">The Tailor</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody">
    <p>Welcome to the Tailor. What kind of clothing would you like to create?</p>
    <div id="tailor-slot-buttons" style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 1rem;">
      <!-- Slot buttons will be dynamically inserted here -->
    </div>
  </div>
</div>

<!-- ==================== TAILOR CRAFTING OVERLAY ==================== -->
<div id="tailor-crafting-overlay" class="overlay">
  <div class="overlayHeader">Crafting Menu</div>
  <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
  <div class="overlayBody" style="display: flex; flex-direction: column; height: calc(100% - 2.2rem); gap: 1rem;">

    <!-- Top Row: Template and Name -->
    <div style="display: flex; gap: 2rem; align-items: center;">
        <div style="flex-basis: 50%;">
            <label for="tailor-template-select">Template:</label>
            <select id="tailor-template-select" onchange="onTemplateSelect()" style="width: 100%;">
                <option value="">--Please choose a template--</option>
            </select>
        </div>
        <div style="flex-basis: 50%;">
            <label for="tailor-item-name">Item Name:</label>
            <input type="text" id="tailor-item-name" disabled style="width: 100%;">
        </div>
    </div>

    <!-- Main Content Area: 3 Columns -->
    <div style="display: flex; flex: 1; gap: 1rem; overflow: hidden;">

      <!-- Column 1: Available Tags (Now Categorized) -->
      <div id="tailor-tags-sections-wrapper" style="flex: 1; display: none; flex-direction: column; min-height: 0;">

        <!-- Materials Dropdown -->
        <div id="tailor-material-section" style="margin-bottom: 1rem;">
            <strong>Material:</strong>
            <select id="tailor-material-select" style="width: 100%; margin-top: 0.25rem;">
                <!-- Material options will be dynamically inserted here -->
            </select>
        </div>

        <!-- Style Tags -->
        <div id="tailor-style-section" style="margin-bottom: 1rem; display: flex; flex-direction: column; min-height: 0;">
            <strong>Style Tags:</strong>
            <div id="tailor-style-tags-container" style="flex: 1; overflow-y: auto; border: 1px solid #444; padding: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.25rem;">
              <!-- Style tag checkboxes will be dynamically inserted here -->
            </div>
        </div>

        <!-- General Tags -->
        <div id="tailor-general-section" style="display: flex; flex-direction: column; min-height: 0; flex: 1;">
            <strong>General Tags:</strong>
            <div id="tailor-general-tags-container" style="flex: 1; overflow-y: auto; border: 1px solid #444; padding: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.25rem;">
              <!-- General tag checkboxes will be dynamically inserted here -->
            </div>
        </div>

      </div>

      <!-- Column 2: Covers -->
      <div style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
        <strong>Covers:</strong>
        <ul id="tailor-coverage-list" style="flex: 1; overflow-y: auto; border: 1px solid #444; padding: 0.5rem; list-style-position: inside; margin-top: 0.5rem; margin-left:0; padding-left: 1.2rem;">
          <!-- Coverage list will be dynamically inserted here -->
        </ul>
      </div>

      <!-- Column 3: Final Tags -->
      <div style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
        <strong>Final Tags:</strong>
        <ul id="tailor-final-tags-list" style="flex: 1; overflow-y: auto; border: 1px solid #444; padding: 0.5rem; list-style-position: inside; margin-top: 0.5rem; margin-left:0; padding-left: 1.2rem;">
            <!-- Final tags will be dynamically inserted here -->
        </ul>
      </div>
    </div>

    <!-- Bottom Button Bar -->
    <div style="padding-top: 1rem; border-top: 1px solid #444; text-align: right;">
        <button id="craft-item-btn" class="overlayBtn" onclick="craftItemFromMenu()">Craft Item</button>
        <button class="overlayBtn" onclick="backToTailorHub()">Back to Slots</button>
    </div>
  </div>
</div>

<!-- ==================== BODY ART STUDIO OVERLAY ==================== -->
<div id="body-art-studio-overlay" class="overlay">
    <div class="overlayHeader">Body Art Studio</div>
    <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
    <div class="overlayBody" style="display: flex; flex-direction: column; gap: 1rem;">
        <!-- Tabs -->
        <div id="body-art-tabs" style="display: flex; border-bottom: 1px solid #444; padding-bottom: 0.5rem; gap: 0.5rem;">
            <button class="overlayBtn" style="flex-grow: 1;" onclick="showBodyArtTab('tattoos')">Tattoos</button>
            <button class="overlayBtn" style="flex-grow: 1;" onclick="showBodyArtTab('piercings')">Piercings</button>
        </div>

        <!-- Tattoo Tab (New Refactored Layout) -->
        <div id="body-art-tab-tattoos" class="body-art-tab" style="display: none; flex-grow: 1; min-height: 0; display: flex; flex-direction: column; gap: 1rem;">
            <!-- Top Row: Selections -->
            <div style="display: flex; gap: 1rem; align-items: center;">
                <div style="flex-basis: 33%;">
                    <label for="tattoo-body-part-select">Body Part:</label>
                    <select id="tattoo-body-part-select" style="width: 100%;" onchange="onTattooPartSelect()"></select>
                </div>
                <div style="flex-basis: 33%;">
                    <label>Design:</label>
                    <p id="tattoo-template-name" style="font-weight: bold; margin: 0;"></p>
                </div>
                <div style="flex-basis: 33%;">
                    <label for="tattoo-name-input">Tattoo Name:</label>
                    <input type="text" id="tattoo-name-input" style="width: 100%;">
                </div>
            </div>

            <!-- Main Content Area: 3 Columns -->
            <div style="display: flex; flex: 1; gap: 1rem; overflow: hidden; min-height: 0;">
                <!-- Column 1: Customization Tags -->
                <div id="tattoo-tags-sections-wrapper" style="flex: 1; display: none; flex-direction: column; gap: 1rem;">
                    <!-- Style Tags, Feature Tags, Size Tags -->
                    <div id="tattoo-style-section">
                        <strong>Style:</strong>
                        <div id="tattoo-style-tags-container" style="border: 1px solid #444; padding: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.25rem;"></div>
                    </div>
                    <div id="tattoo-feature-section">
                        <strong>Features:</strong>
                        <div id="tattoo-feature-tags-container" style="border: 1px solid #444; padding: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.25rem;"></div>
                    </div>
                    <div id="tattoo-size-section">
                        <strong>Size:</strong>
                        <div id="tattoo-size-tags-container" style="border: 1px solid #444; padding: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.25rem;"></div>
                    </div>
                    <div id="tattoo-theme-section">
                        <strong>Theme:</strong>
                        <div id="tattoo-theme-tags-container" style="border: 1px solid #444; padding: 0.5rem; display: flex; flex-direction: column; gap: 0.5rem; margin-top: 0.25rem;"></div>
                    </div>
                </div>

                <!-- Column 2: Preview & Removal -->
                <div style="flex: 1; display: flex; flex-direction: column; min-height: 0; gap: 1rem;">
                    <div style="flex-basis: 50%; display: flex; flex-direction: column;">
                        <strong>Preview & Customization:</strong>
                        <div id="tattoo-preview-container" style="flex: 1; border: 1px solid #444; padding: 0.5rem; margin-top: 0.5rem; background: #111;">
                            <p><strong>Description:</strong> <span id="tattoo-preview-design"></span></p>
                            <div id="tattoo-text-section" style="display: none; margin-top: 0.5rem;">
                                <strong>Custom Text:</strong>
                                <input type="text" id="tattoo-custom-text" style="width: 100%; margin-top: 0.25rem;" oninput="updateTattooPreview()">
                            </div>
                        </div>
                    </div>
                    <div style="flex-basis: 50%; display: flex; flex-direction: column;">
                        <h4>Remove a Tattoo (Cost: $5000)</h4>
                        <div id="current-tattoos-container" style="flex-grow: 1; overflow-y: auto; border: 1px solid #444; padding: 0.5rem; margin-top: 0.5rem;"></div>
                    </div>
                </div>

                <!-- Column 3: Final Tags & Cost -->
                <div style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
                    <strong>Final Tags:</strong>
                    <ul id="tattoo-final-tags-list" style="flex: 1; overflow-y: auto; border: 1px solid #444; padding: 0.5rem; list-style-position: inside; margin-top: 0.5rem; margin-left:0; padding-left: 1.2rem;"></ul>
                </div>
            </div>

            <!-- Bottom Button Bar -->
            <div style="padding-top: 1rem; border-top: 1px solid #444; text-align: right;">
                <button id="get-tattoo-btn" class="overlayBtn" onclick="getTattoo()">Get Tattoo</button>
            </div>
        </div>

        <!-- Piercing Tab (New Crafting Layout) -->
        <div id="body-art-tab-piercings" class="body-art-tab" style="display: none; flex-grow: 1; min-height: 0; display: flex; flex-direction: column; gap: 1rem;">
            <!-- Top Row: Selections -->
            <div style="display: flex; gap: 2rem; align-items: center; margin-bottom: 1rem;">
                <div style="flex-basis: 50%;">
                    <label for="piercing-location-select">Location:</label>
                    <select id="piercing-location-select" style="width: 100%;" onchange="updatePiercingPreview()"></select>
                </div>
                <div style="flex-basis: 50%;">
                    <label for="piercing-material-select">Material:</label>
                    <select id="piercing-material-select" style="width: 100%;" onchange="updatePiercingPreview()"></select>
                </div>
                <div style="flex-basis: 50%;">
                    <label for="piercing-style-select">Style:</label>
                    <select id="piercing-style-select" style="width: 100%;" onchange="updatePiercingPreview()"></select>
                </div>
            </div>

            <!-- Preview & Cost -->
            <div style="border: 1px solid #444; padding: 0.5rem; background: #111;">
                <p><strong>Jewelry:</strong> <span id="piercing-preview-jewelry"></span></p>
                <p><strong>Final Name:</strong> <span id="piercing-preview-name"></span></p>
            </div>

            <!-- Bottom Button Bar -->
            <div style="padding-top: 1rem; border-top: 1px solid #444; text-align: right; margin-top: auto;">
                <button id="get-piercing-btn" class="overlayBtn" onclick="getPiercing()">Get Piercing</button>
            </div>
        </div>
    </div>
</div>

<!-- ==================== MANAGE PIERCINGS OVERLAY ==================== -->
<div id="manage-piercings-overlay" class="overlay">
    <div class="overlayHeader">Manage Piercings</div>
    <div class="overlayClose" onclick="closeAllOverlays()">✖</div>
    <div class="overlayBody" style="display: flex; gap: 1rem; min-height: 0;">
        <!-- Left Column: Equipped -->
        <div style="flex: 1; display: flex; flex-direction: column;">
            <h4>Equipped</h4>
            <div id="equipped-piercings-list" style="flex-grow: 1; overflow-y: auto; border: 1px solid #444; padding: 0.5rem;"></div>
        </div>
        <!-- Right Column: Stored -->
        <div style="flex: 1; display: flex; flex-direction: column;">
            <h4>Stored</h4>
            <div id="stored-piercings-list" style="flex-grow: 1; overflow-y: auto; border: 1px solid #444; padding: 0.5rem;"></div>
        </div>
    </div>
</div>

<!-- ==================== NOTIFICATION OVERLAY ==================== -->
<div id="craft-notification-overlay"></div>
<div id="error-notification-overlay"></div>

<!-- ==================== GRAYSCALE OVERLAY ==================== -->
<div id="grayscale-overlay" class="overlay" style="width: 15rem; height: auto; min-height: 0;">
  <div id="grayscale-picker-container" class="overlayBody hex-picker-container" style="margin-top: 0;">
      <!-- Grayscale hexes will be populated by JS -->
  </div>
</div>

<!-- ==================== SAVE PROMPT OVERLAY ==================== -->
<div id="save-prompt-overlay" class="overlay" style="width: 25vw; height: auto; min-height: 0;">
  <div class="overlayHeader">Enter Save Name</div>
  <div class="overlayBody">
    <input type="text" id="save-name-input" style="width: 100%; margin-bottom: 1rem; padding: 0.4rem;">
    <div style="display: flex; justify-content: flex-end; gap: 0.5rem;">
      <button id="save-cancel-btn" class="overlayBtn">Cancel</button>
      <button id="save-confirm-btn" class="overlayBtn">Save</button>
    </div>
  </div>
</div>

<script>
/* ==============================================================
   CLASSES
   ============================================================== */
class BodyPart {
    constructor(id, name, adjectives = [], size = 'average') {
        this.id = id; // e.g., 'left_thigh'
        this.name = name; // e.g., 'Left Thigh'
        this.descriptor = null; // e.g., 'small', 'large', 'toned'
        this.adjectives = adjectives; // e.g., ['strong', 'scarred']
        this.size = size;
        this.tattoos = []; // Array of TattooItem objects
        this.piercings = []; // Array of PiercingItem objects
    }
}

class EquipmentSlot {
    constructor(id, name, layers = ['skin', 'middle', 'outer']) {
        this.id = id;
        this.name = name;
        layers.forEach(layer => {
            this[layer] = null;
        });
    }
}

class HandHeldSlot {
    constructor(name = 'Hand-held') {
        this.name = name;
        this.left = null;
        this.right = null;
    }
}

class BackSlot {
    constructor(name = 'Back') {
        this.name = name;
        this.item = null;
    }
}


class ClothingItem {
    constructor({
        id,
        templateId, // The original ID from the clothingTemplates object
        name,
        slot, // The ID of the EquipmentSlot it goes into
        layer = null, // 'skin', 'middle', or 'outer'
        covers, // Array of BodyPart IDs it covers
        bonusStats = {}, // e.g., { warmth: 5, style: 10 }
        durability = 100,
        tags = []
    }) {
        this.id = id;
        this.templateId = templateId;
        this.name = name;
        this.slot = slot;
        this.layer = layer;
        this.covers = covers;
        this.bonusStats = bonusStats;
        this.durability = durability;
        this.tags = tags;
    }
}

class TattooItem {
    constructor({
        id, // Unique instance ID
        name, // Final name, e.g., "Large Color Rose Tattoo"
        design, // Final description
        tags = []
    }) {
        this.id = id;
        this.name = name;
        this.design = design;
        this.tags = tags;
    }
}

class PiercingItem {
    constructor({
        id, // Unique instance ID
        name, // Final name, e.g., "Gold Stud"
        bodyPartId, // The specific part it's on
        jewelry, // Description of the jewelry
        tags = []
    }) {
        this.id = id;
        this.name = name;
        this.bodyPartId = bodyPartId;
        this.jewelry = jewelry;
        this.tags = tags;
    }
}

/* ==============================================================
   PIERCING LOGIC (New Crafting System)
   ============================================================== */
function initPiercingTab() {
    const template = piercingTemplates.standard_stud;
    const locationSelect = document.getElementById('piercing-location-select');
    const materialSelect = document.getElementById('piercing-material-select');
    const styleSelect = document.getElementById('piercing-style-select');

    // Filter allowed tags into locations, materials, and styles
    const allLocationTags = template.allowedTags.filter(t => state.playerBody[t]);
    const materialTags = template.allowedTags.filter(t => piercingMaterialTags.includes(t));
    const styleTags = template.allowedTags.filter(t => piercingStyleTags.includes(t));

    // Sort location tags according to the master body part order
    const sortedLocationTags = bodyPartOrder.filter(p => allLocationTags.includes(p));

    locationSelect.innerHTML = sortedLocationTags.map(partId => `<option value="${partId}">${state.playerBody[partId].name}</option>`).join('');
    materialSelect.innerHTML = materialTags.map(mat => `<option value="${mat}">${mat}</option>`).join('');
    styleSelect.innerHTML = styleTags.map(sty => `<option value="${sty}">${sty}</option>`).join('');

    updatePiercingPreview();
}

function updatePiercingPreview() {
    const template = piercingTemplates.standard_stud;
    const location = document.getElementById('piercing-location-select').value;
    const material = document.getElementById('piercing-material-select').value;
    const style = document.getElementById('piercing-style-select').value;

    const jewelryEl = document.getElementById('piercing-preview-jewelry');
    const nameEl = document.getElementById('piercing-preview-name');
    const costBtn = document.getElementById('get-piercing-btn');

    let finalCost = template.baseCost;
    if (material === 'silver') finalCost += 50;
    if (material === 'gold') finalCost += 150;
    if (material === 'titanium') finalCost += 75;
    if (style === 'ring') finalCost += 20;
    if (style === 'barbell') finalCost += 30;
    if (style === 'horseshoe') finalCost += 40;

    const finalJewelry = `a ${material} ${style}`;
    const finalName = `${material.charAt(0).toUpperCase() + material.slice(1)} ${style.charAt(0).toUpperCase() + style.slice(1)}`;

    jewelryEl.textContent = finalJewelry;
    nameEl.textContent = finalName;
    costBtn.textContent = `Get Piercing (${formatMoney(finalCost)})`;
    costBtn.dataset.cost = finalCost;
}

function getPiercing() {
    const location = document.getElementById('piercing-location-select').value;
    const cost = parseFloat(document.getElementById('get-piercing-btn').dataset.cost);

    if (state.money < cost) {
        showErrorNotification("You don't have enough money.");
        return;
    }

    state.money -= cost;
    const name = document.getElementById('piercing-preview-name').textContent;
    const jewelry = document.getElementById('piercing-preview-jewelry').textContent;
    const material = document.getElementById('piercing-material-select').value;
    const style = document.getElementById('piercing-style-select').value;

    const newPiercing = new PiercingItem({
        id: `piercing_${location}_${Date.now()}`,
        name: name,
        bodyPartId: location,
        jewelry: jewelry,
        tags: [location, material, style]
    });

    // Check if body part already has a piercing
    if (state.playerBody[location].piercings.length > 0) {
        // If occupied, add the new piercing to unequipped storage
        state.unequippedPiercings.push(newPiercing);
        showCraftNotification(newPiercing.name, "sent to storage");
    } else {
        // If free, equip it directly
        state.playerBody[location].piercings.push(newPiercing);
        showCraftNotification(newPiercing.name, "Piercing");
    }

    forceGlobalUIRefresh();
}

function openManagePiercings() {
    closeAllOverlays();
    const overlay = document.getElementById('manage-piercings-overlay');
    overlay.style.display = 'block';

    const equippedList = document.getElementById('equipped-piercings-list');
    const storedList = document.getElementById('stored-piercings-list');
    equippedList.innerHTML = '';
    storedList.innerHTML = '';

    let hasEquipped = false;
    for (const partId in state.playerBody) {
        const part = state.playerBody[partId];
        if (part.piercings && part.piercings.length > 0) {
            hasEquipped = true;
            part.piercings.forEach(p => {
                const div = document.createElement('div');
                div.innerHTML = `<span>${p.name} on your ${part.name}</span>`;
                const btn = document.createElement('button');
                btn.className = 'overlayBtn';
                btn.textContent = 'Unequip';
                btn.onclick = () => unequipPiercingToStorage(p.id, partId);
                div.appendChild(btn);
                equippedList.appendChild(div);
            });
        }
    }
    if (!hasEquipped) {
        equippedList.innerHTML = '<p>No piercings equipped.</p>';
    }

    if (state.unequippedPiercings.length > 0) {
        state.unequippedPiercings.forEach(p => {
            const div = document.createElement('div');
            const partName = state.playerBody[p.bodyPartId].name;
            div.innerHTML = `<span>${p.name} (for ${partName})</span>`;
            const btn = document.createElement('button');
            btn.className = 'overlayBtn';
            btn.textContent = 'Equip';
            btn.onclick = () => equipPiercingFromStorage(p.id);
            div.appendChild(btn);
            storedList.appendChild(div);
        });
    } else {
        storedList.innerHTML = '<p>No piercings in storage.</p>';
    }
}

function unequipPiercingToStorage(piercingId, bodyPartId) {
    const part = state.playerBody[bodyPartId];
    const pIndex = part.piercings.findIndex(p => p.id === piercingId);
    if (pIndex > -1) {
        const [piercing] = part.piercings.splice(pIndex, 1);
        state.unequippedPiercings.push(piercing);
        forceGlobalUIRefresh();
        openManagePiercings(); // Refresh the overlay
    }
}

function equipPiercingFromStorage(piercingId) {
    const pIndex = state.unequippedPiercings.findIndex(p => p.id === piercingId);
    if (pIndex > -1) {
        const [piercing] = state.unequippedPiercings.splice(pIndex, 1);
        const bodyPartId = piercing.bodyPartId;

        // Check if the slot is free before equipping
        if (state.playerBody[bodyPartId].piercings.length > 0) {
            showErrorNotification("That body part is already pierced. You must unequip the current piercing first.");
            state.unequippedPiercings.push(piercing); // Put it back
            return;
        }

        state.playerBody[bodyPartId].piercings.push(piercing);
        forceGlobalUIRefresh();
        openManagePiercings(); // Refresh the overlay
    }
}

/* ==============================================================
   FACTORIES
   ============================================================== */
function createPlayerBody(sex = 'female') {
    const body = {};
    const addPart = (id, name) => {
        body[id] = new BodyPart(id, name);
    };
    const addPairedParts = (baseId, baseName) => {
        addPart(`left_${baseId}`, `Left ${baseName}`);
        addPart(`right_${baseId}`, `Right ${baseName}`);
    };

    // Head & Face
    addPart('head', 'Head');
    addPart('neck', 'Neck');
    addPart('face', 'Face');
    addPart('forehead', 'Forehead');
    addPairedParts('eye', 'Eye');
    addPairedParts('ear', 'Ear');
    addPart('nose', 'Nose');
    addPart('lips', 'Lips');
    addPart('tongue', 'Tongue');

    // Torso
    addPart('chest', 'Chest');
    addPart('belly', 'Belly');
    addPart('waist', 'Waist');
    addPart('upper_back', 'Upper Back');
    addPart('lower_back', 'Lower Back');

    // Groin & Butt
    addPart('groin', 'Groin');
    // addPart('butt', 'Buttocks'); // Removed to prevent duplicate descriptor issues
    addPairedParts('ass_cheek', 'Ass Cheek');
    addPart('anus', 'Anus');

    // Limbs
    addPairedParts('arm', 'Arm');
    addPairedParts('wrist', 'Wrist');
    addPairedParts('hand', 'Hand');
    addPairedParts('thigh', 'Thigh');
    addPairedParts('calf', 'Calf');
    addPairedParts('ankle', 'Ankle');
    addPairedParts('foot', 'Foot');

    // Conditional parts based on sex
    if (sex === 'female') {
        addPairedParts('breast', 'Breast');
        addPairedParts('nipple', 'Nipple');
        addPart('vagina', 'Vagina');
    } else if (sex === 'male') {
        addPart('penis', 'Penis');
    }

    return body;
}

const sexActions = {
    // Player-only actions
    player: {
        mouth: [],
        vagina: [
            { name: 'Squeeze', description: "{actor} tightens their vaginal muscles around {target}, eliciting a soft groan.", requiredState: 'vaginal_sex', arousalGiver: 10, arousalReceiver: 5, tags: ['vaginal'] }
        ],
        anus: [
            { name: 'Squeeze', description: "{actor} tightens their anal muscles around {target}, eliciting a soft groan.", requiredState: 'anal_sex', arousalGiver: 10, arousalReceiver: 5, tags: ['anal'] }
        ]
    },
    // Universal actions that can be performed by anyone
    universal: {
        left_hand: [
            { name: 'Remove Top', description: "{actor} deftly unbuttons and removes {target}'s top, revealing what lies beneath.", requiredState: 'main', arousalGiver: 2, arousalReceiver: 5, tags: ['undress', 'top'] },
            { name: 'Remove Bottoms', description: "{actor} slides {target}'s bottoms down and off, their eyes lingering on {target}'s form.", requiredState: 'main', arousalGiver: 2, arousalReceiver: 5, tags: ['undress', 'bottom'] },
            { name: 'Squeeze Hand', description: "{actor} gently takes {target}'s hand, giving it a reassuring squeeze before lacing their fingers together.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 5, arousalReceiver: 5, tags: ['affectionate'] },
            { name: 'Stroke Cheek', description: "{actor} softly cups {target}'s face, their thumb stroking gently across their cheek.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 5, arousalReceiver: 7, tags: ['affectionate'] },
            { name: 'Tease Breasts', description: "{actor} gently teases {target}'s breasts, their fingers dancing lightly over the sensitive skin.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 5, arousalReceiver: 15, tags: ['manual'], requires_no_clothing_on_target: 'chest' },
            { name: 'Explore Vagina', description: "{actor} slowly explores the folds of {target}'s vagina, their touch sending shivers through {target}.", requiredState: 'main', arousalGiver: 7, arousalReceiver: 20, tags: ['manual', 'vaginal'], requires_no_clothing_on_target: 'vagina' },
            { name: 'Tease through Fabric', description: "{actor} slips their hand under {target}'s panties, teasing them through the thin fabric.", requiredState: 'main', nextState: 'hand_in_panties', arousalGiver: 7, arousalReceiver: 15, tags: ['manual', 'tease'], requires_clothing: 'underwear' },
            { name: 'Gentle Fingering', description: "{actor} begins to gently finger {target}'s vagina, their movements slow and deliberate.", requiredState: 'hand_in_panties', arousalGiver: 10, arousalReceiver: 25, tags: ['manual', 'insertion', 'vaginal'] }
        ],
        right_hand: [
            // Mirrored actions for the other hand
            { name: 'Remove Top', description: "{actor} deftly unbuttons and removes {target}'s top, revealing what lies beneath.", requiredState: 'main', arousalGiver: 2, arousalReceiver: 5, tags: ['undress', 'top'] },
            { name: 'Remove Bottoms', description: "{actor} slides {target}'s bottoms down and off, their eyes lingering on {target}'s form.", requiredState: 'main', arousalGiver: 2, arousalReceiver: 5, tags: ['undress', 'bottom'] },
            { name: 'Squeeze Hand', description: "{actor} gently takes {target}'s hand, giving it a reassuring squeeze before lacing their fingers together.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 5, arousalReceiver: 5, tags: ['affectionate'] },
            { name: 'Stroke Cheek', description: "{actor} softly cups {target}'s face, their thumb stroking gently across their cheek.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 5, arousalReceiver: 7, tags: ['affectionate'] },
            { name: 'Tease Breasts', description: "{actor} gently teases {target}'s breasts, their fingers dancing lightly over the sensitive skin.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 5, arousalReceiver: 15, tags: ['manual'], requires_no_clothing_on_target: 'chest' },
            { name: 'Explore Vagina', description: "{actor} slowly explores the folds of {target}'s vagina, their touch sending shivers through {target}.", requiredState: 'main', arousalGiver: 7, arousalReceiver: 20, tags: ['manual', 'vaginal'], requires_no_clothing_on_target: 'vagina' },
            { name: 'Tease through Fabric', description: "{actor} slips their hand under {target}'s panties, teasing them through the thin fabric.", requiredState: 'main', nextState: 'hand_in_panties', arousalGiver: 7, arousalReceiver: 15, tags: ['manual', 'tease'], requires_clothing: 'underwear' },
            { name: 'Gentle Fingering', description: "{actor} begins to gently finger {target}'s vagina, their movements slow and deliberate.", requiredState: 'hand_in_panties', arousalGiver: 10, arousalReceiver: 25, tags: ['manual', 'insertion', 'vaginal'] }
        ],
        mouth: [
            { name: 'Whisper Seductively', description: "{actor} leans in close and whispers something seductive in {target}'s ear.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 10, arousalReceiver: 15, tags: ['oral', 'seduction'] },
            { name: 'Passionate Kiss', description: "{actor} pulls {target} into a deep, passionate kiss, their tongues dancing together.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 10, arousalReceiver: 10, tags: ['oral', 'affectionate'] },
            { name: 'Nibble on Neck', description: "{actor} presses their lips to {target}'s neck, leaving a trail of soft kisses and gentle nibbles.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 7, arousalReceiver: 12, tags: ['oral'] },
            { name: 'Worship Nipples', description: "{actor} takes one of {target}'s nipples into their mouth, licking and sucking gently.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 12, arousalReceiver: 20, tags: ['oral'], requires_no_clothing_on_target: 'left_nipple' },
            { name: 'Oral Worship', description: "{actor} kneels down and begins to worship {target}'s vagina with their mouth.", requiredState: 'main', arousalGiver: 15, arousalReceiver: 30, tags: ['oral', 'vaginal'], requires_no_clothing_on_target: 'vagina' }
        ],
        penis: [
            // This is an NPC-only action group for now
            { name: 'Begin Vaginal Sex', description: "{actor} aligns themselves and slowly penetrates {target}'s vagina, a soft gasp escaping their lips.", requiredState: 'main', nextState: 'vaginal_sex', arousalGiver: 20, arousalReceiver: 20, tags: ['insertion', 'penetration', 'vaginal', 'npc-only'], requires_no_clothing_on_target: 'vagina' },
            { name: 'Begin Anal Sex', description: "{actor} carefully positions themselves and penetrates {target}'s anus, their movements slow and deliberate.", requiredState: 'main', nextState: 'anal_sex', arousalGiver: 15, arousalReceiver: 30, tags: ['insertion', 'penetration', 'anal', 'npc-only'], requires_no_clothing_on_target: 'anus' }
        ],
        vagina: [
             { name: 'Gentle Thrusts', description: "{actor} begins a rhythm of slow, gentle thrusts, their bodies moving in sync.", requiredState: 'vaginal_sex', arousalGiver: 10, arousalReceiver: 15, tags: ['vaginal', 'penetration'] },
             { name: 'Thrust hard', description: "{actor} thrusts hard into {target}, their movements becoming more forceful and demanding.", requiredState: 'vaginal_sex', arousalGiver: 15, arousalReceiver: 20, tags: ['vaginal', 'penetration'] },
             { name: 'Tease and Deny', description: "{actor} slows their rhythm, teasing and denying {target} the release they crave.", requiredState: 'vaginal_sex', arousalGiver: 5, arousalReceiver: -10, tags: ['vaginal', 'penetration', 'edging'] },
             { name: 'Withdraw', description: "{actor} slowly withdraws from {target}, their bodies separating with a soft sound.", requiredState: 'vaginal_sex', nextState: 'main', arousalGiver: 2, arousalReceiver: -5, tags: ['vaginal'] }
        ],
        anus: [
             { name: 'Gentle Thrusts', description: "{actor} begins a rhythm of slow, gentle thrusts, their bodies moving in sync.", requiredState: 'anal_sex', arousalGiver: 10, arousalReceiver: 15, tags: ['anal', 'penetration'] },
             { name: 'Thrust hard', description: "{actor} thrusts hard into {target}, their movements becoming more forceful and demanding.", requiredState: 'anal_sex', arousalGiver: 15, arousalReceiver: 25, tags: ['anal', 'penetration'] },
             { name: 'Withdraw', description: "{actor} slowly withdraws from {target}, their bodies separating with a soft sound.", requiredState: 'anal_sex', nextState: 'main', arousalGiver: 2, arousalReceiver: -5, tags: ['anal'] }
        ],
        legs: [
            { name: 'Leg Lock', description: "{actor} wraps their legs tightly around {target}'s waist, pulling them closer.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 5, arousalReceiver: 10, tags: ['legs', 'tease'] },
            { name: 'Sensual Rub', description: "{actor} slowly rubs their legs against {target}'s, the friction sending sparks between them.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 7, arousalReceiver: 12, tags: ['legs', 'tease'] }
        ],
        breasts: [
            { name: 'Body Press', description: "{actor} presses their breasts firmly against {target}'s body, letting them feel their warmth.", requiredState: ['main', 'vaginal_sex', 'anal_sex'], arousalGiver: 10, arousalReceiver: 10, tags: ['tease'] }
        ]
    }
};

/* ==============================================================
   GLOBAL STATE
   ============================================================== */
const state = {
  /* -------------------- Time -------------------- */
  currentTime: new Date('2007-08-01T09:00:00'),   // start time (unchanged)
  calendarDate: null,

  /* -------------------- Money ------------------- */
  money: 0.00,

  /* -------------------- Intro events ------------ */
  eventIndex: 0,
  events: [
    {title:"Meet Maya",text:"Maya Alvarez, a marine biologist, woke up feeling a strange pressure in her abdomen. An alien worm‑like parasite has taken residence inside her, feeding off her nervous system."},
    {title:"Friend – Leah",text:"Leah Patel, Maya’s longtime friend, calls to check in. She senses something is off but Maya brushes it aside.", reveals: "Leah"},
    {title:"Friend – Amir",text:"Dr. Amir Khan, a neuro‑biology researcher, offers to run scans. He warns Maya about the risks of unknown pathogens.", reveals: "Amir"},
    {title:"Friend – Toby",text:"Toby, the lab’s tech specialist, jokes about “alien pets.” He hands Maya a bottle of energy drink.", reveals: "Toby"}
  ],

  /* -------------------- Needs ------------------- */
  needs: {
    tiredness: 10000,
    stress: 0,
    trauma: 0,
    happiness: 1000,
    arousal: 0,
    corruption: 0,
    alcohol: 0,
    drugs: 0
  },

  ranges: {
    tiredness: 10000,
    stress: 1000,
    trauma: 1000,
    happiness: 1000,
    arousal: 1000,
    corruption: 1000,
    alcohol: 100,
    drugs: 100
  },

  /* -------------------- Flags -------------------- */
  showCorruption: false,   // toggled from Cheats overlay
  cheatsEnabled: false,     // set by Settings → Enable Cheats
  storyEventActive: false, // disables stat-triggered events

  /* -------------------- Skills ------------------- */
  skills: {
    "PH skill 1": { level: 1, exp: 0 }, "PH skill 2": { level: 1, exp: 0 }, "PH skill 3": { level: 1, exp: 0 }, "PH skill 4": { level: 1, exp: 0 }, "PH skill 5": { level: 1, exp: 0 },
    "PH skill 6": { level: 1, exp: 0 }, "PH skill 7": { level: 1, exp: 0 }, "PH skill 8": { level: 1, exp: 0 }, "PH skill 9": { level: 1, exp: 0 }, "PH skill 10": { level: 1, exp: 0 },
    "PH skill 11": { level: 1, exp: 0 }, "PH skill 12": { level: 1, exp: 0 }, "PH skill 13": { level: 1, exp: 0 }, "PH skill 14": { level: 1, exp: 0 }, "PH skill 15": { level: 1, exp: 0 },
    "PH skill 16": { level: 1, exp: 0 }, "PH skill 17": { level: 1, exp: 0 }, "PH skill 18": { level: 1, exp: 0 }, "PH skill 19": { level: 1, exp: 0 }, "PH skill 20": { level: 1, exp: 0 },
    "PH skill 21": { level: 1, exp: 0 }, "PH skill 22": { level: 1, exp: 0 }, "PH skill 23": { level: 1, exp: 0 }, "PH skill 24": { level: 1, exp: 0 }, "PH skill 25": { level: 1, exp: 0 },
    "PH skill 26": { level: 1, exp: 0 }, "PH skill 27": { level: 1, exp: 0 }, "PH skill 28": { level: 1, exp: 0 }, "PH skill 29": { level: 1, exp: 0 }, "PH skill 30": { level: 1, exp: 0 },
    "PH skill 31": { level: 1, exp: 0 }, "PH skill 32": { level: 1, exp: 0 }, "PH skill 33": { level: 1, exp: 0 }, "PH skill 34": { level: 1, exp: 0 }, "PH skill 35": { level: 1, exp: 0 },
    "PH skill 36": { level: 1, exp: 0 }, "PH skill 37": { level: 1, exp: 0 }, "PH skill 38": { level: 1, exp: 0 }, "PH skill 39": { level: 1, exp: 0 }, "PH skill 40": { level: 1, exp: 0 },
    "PH skill 41": { level: 1, exp: 0 }, "PH skill 42": { level: 1, exp: 0 }, "PH skill 43": { level: 1, exp: 0 }, "PH skill 44": { level: 1, exp: 0 }, "PH skill 45": { level: 1, exp: 0 },
    "PH skill 46": { level: 1, exp: 0 }, "PH skill 47": { level: 1, exp: 0 }, "PH skill 48": { level: 1, exp: 0 }, "PH skill 49": { level: 1, exp: 0 }, "PH skill 50": { level: 1, exp: 0 }
  },

  /* -------------------- Character Physicality -------------------- */
  sex: 'female',
  playerBody: {}, // Will be populated by factory
  appearance: {
      birthDate: '1989-02-12',
      hairLength: 10, // Default value, maybe cm
      height: 170, // Default value, cm
      skinColor: { name: 'Pale', hex: '#F0D4C2' },
      hairColor: { name: 'Brown', hex: '#5C4033' },
      eyeColor: { name: 'Brown', hex: '#5C4033' }
  },
  equipment: {
    head: new EquipmentSlot('head', 'Head'),
    neck: new EquipmentSlot('neck', 'Neck'),
    upper: new EquipmentSlot('upper', 'Upper Body'),
    lower: new EquipmentSlot('lower', 'Lower Body'),
    waist: new EquipmentSlot('waist', 'Waist'),
    arms: new EquipmentSlot('arms', 'Arms'),
    hands: new EquipmentSlot('hands', 'Hands'),
    legs: new EquipmentSlot('legs', 'Legs'),
    feet: new EquipmentSlot('feet', 'Feet'),
    'hand-held': new HandHeldSlot('Hand-held'),
    back: new BackSlot('Back')
  },
  inventory: [],
  unequippedPiercings: [], // For the new management system

  /* -------------------- Stats -------------------- */
  stats: {
    timesSlept: 0,
    questsCompleted: 0,
    itemsCrafted: 0,
    distanceWalked: 0,
    timesCollapsedFromStress: 0,
    timesClimaxed: 0,
    // New Sex Stats
    vaginalSexCount: 0,
    analSexCount: 0,
    oralSexGivenCount: 0,
    oralSexReceivedCount: 0,
    vaginalCreampiesReceived: 0,
    analCreampiesReceived: 0,
    oralCreampiesReceived: 0,
    timesSwallowedSemen: 0,
    totalGirlCumExpelled: 0,
    uniqueSexualPartners: 0
  },

  /* -------------------- Reproductive System -------------------- */
  bodyFluids: {
    vagina: { semen: [] }, // Each entry: { fatherId: '...', volume: X }
    anus: { semen: [] },
    mouth: { semen: [] },
    body: { semen: [] } // For external coverage
  },
  womb: {
    semenVolume: 0 // in ml, to be deprecated but kept for save compatibility
  },
  menstrualCycle: {
    cycleLength: 28,
    periodLength: 5,
    currentDayInCycle: 1,
    isFertile: false
  },
  pregnancy: {
    isPregnant: false,
    type: null, // 'human' or 'parasite'
    days: 0,
    eggCount: 0,
    discoveryEventTriggered: false
  },
  parasite: {
      canImpregnate: false,
      eggs: [], // Each egg: {id, laidAtTime, hatchAtTime, birthReadyTime, isDiscovered}
      worms: [] // Each worm: { id, birthReadyTime }
  },

  /* -------------------- NPCs --------------------- */
  npcs: {
    "Leah": { relationship: 0, trust: 0, fear: 0, attraction: 0, hidden: true, semenId: "leah_semen_id", cumProduction: 5 },
    "Amir": { relationship: 0, trust: 0, fear: 0, attraction: 0, hidden: true, semenId: "amir_semen_id", cumProduction: 7 },
    "Toby": { relationship: 0, trust: 0, fear: 0, attraction: 0, hidden: true, semenId: "toby_semen_id", cumProduction: 10 }
  },

  /* -------------------- Journal ------------------ */
  journal: {
    quests: [
      { title: "Uncover the Truth", description: "Find out more about the alien parasite and its origins.", complete: false },
      { title: "Get some rest", description: "You were feeling exhausted, but you took a nap.", complete: true },
      { title: "A Hidden Quest", description: "This quest is hidden until its conditions are met.", complete: false, hidden: true }
    ],
    reminders: [{ date: '2007-08-07', text: 'Appointment with Dr. Amir at 2pm' }],
    recurringReminders: [
        { month: 2, day: 5, text: "It's my birthday next week!" }
    ],
    notes: "I can write my own notes here."
  },

  settings: {
    fontFamily: 'Arial, Helvetica, sans-serif',
    fontSize: '1rem'
  },

  ui: {
    lastCharTab: 'status',
    lastCheatTab: 'general'
  },

  /* -------------------- Sex Scene State ------------------ */
  sexScene: {
      isActive: false,
      actors: [], // { id, arousal, maxArousal, hasClimaxed, clothing, initialClothing }
      turn: '',
      log: [],
      currentState: 'foreplay',
      initialPlayerClothing: null
  },

  /* -------------------- Game Location ------------------ */
  currentLocation: 'event_intro',
  locationBeforeEvent: '',

  scenes: {
    'foyer': {
      title: 'Laboratory Foyer',
      description: 'The foyer is dimly lit, metal doors line the walls, and a low hum of equipment reverberates through the concrete floor. A faint smell of antiseptic hangs in the air.',
      nav: [
        { text: 'Kitchen', action: "goToScene('kitchen', 30)" },
        { text: 'Lounge', action: "goToScene('lounge', 30)" },
        { text: 'Bathroom', action: "goToScene('bathroom', 30)" },
        { text: 'Private Room', action: "goToScene('private_room', 30)" },
        { text: 'Visit the Tailor', action: "goToTailorHub()" },
        { text: 'Visit Body Art Studio', action: "openBodyArtStudio()" },
        {
          text: 'Check in with Leah',
          action: "goToScene('leah_love_event', 0)",
          condition: { type: 'npc_relationship', npc: 'Leah', operator: '>=', value: 50 }
        },
        {
          text: 'Check in with Amir',
          action: "goToScene('amir_love_event', 0)",
          condition: { type: 'npc_relationship', npc: 'Amir', operator: '>=', value: 50 }
        },
        {
          text: 'Check in with Toby',
          action: "goToScene('toby_love_event', 0)",
          condition: { type: 'npc_relationship', npc: 'Toby', operator: '>=', value: 50 }
        }
      ],
      randomEvents: [
        { chance: 0.2, scene: 'random_foyer_1' }
      ]
    },
    'kitchen': {
      title: 'Kitchen',
      description: 'Stainless steel counters glint under harsh fluorescent lights. A coffee maker gurgles, and a half-eaten sandwich rests on a plate. The scent of stale coffee lingers. The fridge hums softly, casting a faint blue glow across the tiled floor.',
      nav: [
        { text: 'Back to Foyer', action: "goToScene('foyer', 30)" }
      ],
      randomEvents: [
        { chance: 0.2, scene: 'random_kitchen_1' },
        {
          chance: 0.3, // 30% chance when conditions are met
          scene: 'parasite_craving_event',
          condition: { type: 'parasite_pregnancy' }
        }
      ]
    },
    'private_room': {
      title: 'Private Room',
      description: 'This is a small, quiet room off the main foyer. It seems to be unused, containing little more than a simple cot and a small desk. There is a strange, organic-looking structure in the corner.',
      nav: [
        { text: 'Back to Foyer', action: "goToScene('foyer', 30)" },
        { text: 'Manage Piercings', action: "openManagePiercings()", condition: { type: 'has_piercings' } },
        {
          text: 'Approach the Nest',
          action: "goToScene('nest', 0)",
          condition: { type: 'parasite_impregnate_enabled' }
        }
      ]
    },
    'nest': {
      title: 'The Nest',
      description: 'The structure is a grotesque, pulsating mass of organic tissue, clearly of alien origin. It seems to be... waiting. You feel a strange pull towards it, a primal urge to settle within its strange embrace.',
      nav: [
        { text: 'Leave the nest', action: "goToScene('private_room', 0)" },
        {
          text: 'Deliver the alien worms',
          action: "deliverWorms()",
          condition: { type: 'worms_ready_to_birth' }
        }
      ]
    },
    'birth_results': {
        title: 'Delivery',
        description: 'After a grueling and bizarre ordeal, you have delivered the alien worms into the nest. You feel a sense of relief, but also a deep violation. The nest pulses gently, seeming to nurture its new inhabitants.',
        nav: [
            { text: 'Leave the area', action: "finishBirthing()" }
        ]
    },
    'lounge': {
      title: 'Lounge',
      description: 'Plush chairs face a wall-mounted screen playing calming nature footage. Shelves hold scientific journals and a few well-worn novels. Soft ambient music drifts.',
      nav: [
        { text: 'Back to Foyer', action: "goToScene('foyer', 30)" },
        { text: 'Relax', action: "goToScene('relaxing', 0)" },
        { text: 'Rest for the day', action: "passDayInLounge()" },
        { text: 'Test Sex Scene with Toby', action: "startSexScene(['player', 'Toby'])" },
        { text: 'Test Sex Scene with Leah', action: "startSexScene(['player', 'Leah'])" }
      ],
      randomEvents: [
        { chance: 0.2, scene: 'random_lounge_1' }
      ]
    },
    'bathroom': {
      title: 'Bathroom',
      description: 'White tiles line the walls, a single sink flickers with a weak bulb. The mirror fogs slightly as warm air circulates. A small cabinet holds basic toiletries.',
      nav: [
        { text: 'Back to Foyer', action: "goToScene('foyer', 30)" },
        { text: 'Take a shower', action: "goToScene('showering', 0)" }
      ],
      randomEvents: [
        { chance: 0.2, scene: 'random_bathroom_1' },
        {
          chance: 0.4, // 40% chance when conditions are met
          scene: 'morning_sickness_event',
          condition: { type: 'human_pregnancy_early' }
        }
      ]
    },
    'showering': {
      title: 'Shower',
      description: 'You undress and take a shower.',
      nav: [
        { text: 'Finish', action: "finishShower()" }
      ]
    },
    'relaxing': {
      title: 'Relaxing',
      description: 'You sit back and relax for a while.',
      nav: [
        { text: 'Finish', action: "finishRelaxing()" }
      ]
    },
    'random_foyer_1': {
      title: 'A Glimmer',
      description: 'You notice a strange glimmer near the air vent, but it vanishes as you approach.',
      nav: [
        { text: 'Continue', action: "goToScene('foyer', 0)" }
      ]
    },
    'random_kitchen_1': {
      title: 'A Strange Smell',
      description: 'A strange, sickly sweet smell emanates from the drain. You make a mental note to get it checked out.',
      nav: [
        { text: 'Continue', action: "goToScene('kitchen', 0)" }
      ]
    },
    'random_lounge_1': {
      title: 'A Flicker on the Screen',
      description: 'For a brief moment, the calming nature footage on the screen is replaced by a flash of static and what looks like alien text.',
      nav: [
        { text: 'Continue', action: "goToScene('lounge', 0)" }
      ]
    },
    'random_bathroom_1': {
      title: 'A Puddle',
      description: 'You notice a small, iridescent puddle forming under the sink, but it evaporates before you can get a closer look.',
      nav: [
        { text: 'Continue', action: "goToScene('bathroom', 0)" }
      ]
    },
    'leah_love_event': {
      title: 'A Moment with Leah',
      description: 'Placeholder text for a special moment with Leah.',
      nav: [
        { text: 'Return to Foyer', action: "goToScene('foyer', 0)" }
      ]
    },
'tailor_hub': {
    title: 'The Tailor',
    description: 'The tailor is a mysterious figure who can create any clothing you desire, for a price. What would you like to create?',
    nav: [] // This will be populated dynamically
},
    'amir_love_event': {
      title: 'A Moment with Amir',
      description: 'Placeholder text for a special moment with Amir.',
      nav: [
        { text: 'Return to Foyer', action: "goToScene('foyer', 0)" }
      ]
    },
    'toby_love_event': {
      title: 'A Moment with Toby',
      description: 'Placeholder text for a special moment with Toby.',
      nav: [
        { text: 'Return to Foyer', action: "goToScene('foyer', 0)" }
      ]
    },
    'stress_collapse_event': {
      title: 'Overwhelmed',
      description: 'The weight of everything becomes too much. The world spins and fades to black as you collapse from the stress.',
      nav: [
        { text: 'Wake up later...', action: "recoverFromStressCollapse()" }
      ]
    },
    'arousal_max_event': {
      title: 'Overcome',
      description: 'A wave of intense pleasure washes over you, so powerful it leaves you breathless and trembling on the floor.',
      nav: [
        { text: 'Recover...', action: "recoverFromArousalMax()" }
      ]
    },
    'morning_sickness_event': {
      title: 'Morning Sickness',
      description: 'A wave of nausea hits you suddenly, and you barely make it to the nearest receptacle before you\'re sick. The feeling passes after a few moments, leaving you feeling drained and miserable.',
      nav: [
        { text: 'Pull yourself together.', action: "handleMorningSickness()" }
      ]
    },
    'parasite_craving_event': {
      title: 'Unusual Hunger',
      description: 'A sudden, ravenous hunger grips you. It\'s not for anything normal. You find yourself craving the taste of metal, the texture of plastic, anything to satisfy the strange gnawing in your gut. You manage to resist the urge, but it leaves you feeling shaken and disturbed.',
      nav: [
        { text: 'This is not my body...', action: "handleParasiteCraving()" }
      ]
    },
    'human_water_breaking_event': {
      title: 'A Sudden Gush',
      description: 'You feel a sudden, warm gush between your legs. Your water has broken. It seems the time is near.',
      nav: [
        { text: 'Prepare for what comes next...', action: "goToScene('human_birth_event', 0)" }
      ]
    },
    'human_birth_event': {
      title: 'Birth',
      description: 'After a long and exhausting labor, you give birth to a healthy baby. [This is a placeholder event.]',
      nav: [
        { text: 'A new chapter begins.', action: "completeHumanBirth()" }
      ]
    },
    'parasite_takeover_event': {
      title: 'A Vicious Change',
      description: 'A sudden, sharp pain lances through your abdomen, far more intense than any cramp you\'ve felt before. You double over, gasping, as a strange, cold sensation spreads from your womb. The subtle warmth of the life you were carrying vanishes, replaced by an alien chill. Something is terribly wrong.',
      nav: [
        { text: 'Endure it...', action: "endTakeoverEvent()" }
      ]
    },
    'human_pregnancy_discovery': {
      title: 'A New Possibility',
      description: 'You\'ve been feeling off for a couple of weeks now—unusually tired, a bit nauseous in the mornings. Looking at the calendar, a sudden thought strikes you. Could you be... pregnant?',
      nav: [
        { text: 'A wave of uncertainty washes over you.', action: "endDiscoveryEvent()" }
      ]
    },
    'parasite_hatch_event': {
      title: 'A New Horror',
      description: 'A sharp, agonizing pain rips through your abdomen. It feels like something tearing its way out from the inside. The sensation is brief but terrifying, leaving you weak, trembling, and with the sickening knowledge that something has just hatched inside you.',
      nav: [
        { text: 'Oh god, what was that...', action: "handleEggHatching()" }
      ]
    },
    'sex_cleanup': {
      title: 'Gathering Yourself',
      description: 'You take a moment to fix your clothes and compose yourself before continuing.',
      nav: [
        { text: 'Continue', action: "returnFromSexScene()" }
      ]
    }
  }
};

/* ==============================================================
   TATTOO & PIERCING TEMPLATES
   ============================================================== */
const tattooTemplates = {
    // Head & Face
    'face': { name: 'Face Tattoo', baseDesign: 'a small design on your face', baseCost: 400, allowedTags: ['tiny', 'small', 'lettering', 'linework', 'minimalist', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'forehead': { name: 'Forehead Tattoo', baseDesign: 'a design on your forehead', baseCost: 450, allowedTags: ['tiny', 'small', 'medium', 'geometric', 'lettering', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'left_ear': { name: 'Left Ear Tattoo', baseDesign: 'a delicate design on your left ear', baseCost: 200, allowedTags: ['tiny', 'linework', 'minimalist', 'geometric', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_ear': { name: 'Right Ear Tattoo', baseDesign: 'a delicate design on your right ear', baseCost: 200, allowedTags: ['tiny', 'linework', 'minimalist', 'geometric', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'nose': { name: 'Nose Tattoo', baseDesign: 'a subtle design on your nose', baseCost: 250, allowedTags: ['tiny', 'dotwork', 'minimalist', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'lips': { name: 'Lip Tattoo', baseDesign: 'a design on your inner lip', baseCost: 300, allowedTags: ['tiny', 'small', 'lettering', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'neck': { name: 'Neck Tattoo', baseDesign: 'a design on your neck', baseCost: 500, allowedTags: ['small', 'medium', 'tribal', 'geometric', 'lettering', 'neo traditional', 'blackwork', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    // Torso
    'chest': { name: 'Chest Tattoo', baseDesign: 'a piece covering your chest', baseCost: 1200, allowedTags: ['medium', 'large', 'american traditional', 'neo traditional', 'japanese', 'realism', 'blackwork', 'color', 'shading', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'belly': { name: 'Belly Tattoo', baseDesign: 'a design centered on your belly', baseCost: 800, allowedTags: ['small', 'medium', 'large', 'lettering', 'neo traditional', 'watercolor', 'color', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'upper_back': { name: 'Upper Back Tattoo', baseDesign: 'a large piece across your upper back', baseCost: 1500, allowedTags: ['medium', 'large', 'full-back', 'tribal', 'japanese', 'realism', 'blackwork', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'lower_back': { name: 'Lower Back Tattoo', baseDesign: 'a design on your lower back', baseCost: 700, allowedTags: ['small', 'medium', 'large', 'tribal', 'lettering', 'neo traditional', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    // Groin & Butt
    'groin': { name: 'Groin Tattoo', baseDesign: 'an intricate design above your groin', baseCost: 700, allowedTags: ['tiny', 'small', 'medium', 'tribal', 'geometric', 'minimalist', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'vagina': { name: 'Vagina Tattoo', baseDesign: 'a delicate design accenting your mound', baseCost: 900, allowedTags: ['tiny', 'small', 'watercolor', 'neo traditional', 'minimalist', 'color', 'linework', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'left_ass_cheek': { name: 'Left Ass Cheek Tattoo', baseDesign: 'a design on your left ass cheek', baseCost: 400, allowedTags: ['tiny', 'small', 'medium', 'lettering', 'american traditional', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_ass_cheek': { name: 'Right Ass Cheek Tattoo', baseDesign: 'a design on your right ass cheek', baseCost: 400, allowedTags: ['tiny', 'small', 'medium', 'lettering', 'american traditional', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'anus': { name: 'Anus Tattoo', baseDesign: 'a decorative pattern around your anus', baseCost: 1200, allowedTags: ['tiny', 'small', 'geometric', 'dotwork', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    // Limbs
    'left_arm': { name: 'Left Arm Tattoo', baseDesign: 'a design on your left arm', baseCost: 900, allowedTags: ['small', 'medium', 'large', 'full-sleeve', 'american traditional', 'japanese', 'realism', 'blackwork', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_arm': { name: 'Right Arm Tattoo', baseDesign: 'a design on your right arm', baseCost: 900, allowedTags: ['small', 'medium', 'large', 'full-sleeve', 'american traditional', 'japanese', 'realism', 'blackwork', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'left_wrist': { name: 'Left Wrist Tattoo', baseDesign: 'a small design on your left wrist', baseCost: 250, allowedTags: ['tiny', 'small', 'lettering', 'minimalist', 'linework', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_wrist': { name: 'Right Wrist Tattoo', baseDesign: 'a small design on your right wrist', baseCost: 250, allowedTags: ['tiny', 'small', 'lettering', 'minimalist', 'linework', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'left_hand': { name: 'Left Hand Tattoo', baseDesign: 'a design on your left hand', baseCost: 350, allowedTags: ['tiny', 'small', 'geometric', 'dotwork', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_hand': { name: 'Right Hand Tattoo', baseDesign: 'a design on your right hand', baseCost: 350, allowedTags: ['tiny', 'small', 'geometric', 'dotwork', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'left_thigh': { name: 'Left Thigh Tattoo', baseDesign: 'a design on your left thigh', baseCost: 1000, allowedTags: ['medium', 'large', 'neo traditional', 'watercolor', 'realism', 'color', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_thigh': { name: 'Right Thigh Tattoo', baseDesign: 'a design on your right thigh', baseCost: 1000, allowedTags: ['medium', 'large', 'neo traditional', 'watercolor', 'realism', 'color', 'blackwork', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'left_calf': { name: 'Left Calf Tattoo', baseDesign: 'a design on your left calf', baseCost: 600, allowedTags: ['small', 'medium', 'large', 'american traditional', 'tribal', 'blackwork', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_calf': { name: 'Right Calf Tattoo', baseDesign: 'a design on your right calf', baseCost: 600, allowedTags: ['small', 'medium', 'large', 'american traditional', 'tribal', 'blackwork', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'left_ankle': { name: 'Left Ankle Tattoo', baseDesign: 'a small design on your left ankle', baseCost: 250, allowedTags: ['tiny', 'small', 'minimalist', 'linework', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_ankle': { name: 'Right Ankle Tattoo', baseDesign: 'a small design on your right ankle', baseCost: 250, allowedTags: ['tiny', 'small', 'minimalist', 'linework', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'left_foot': { name: 'Left Foot Tattoo', baseDesign: 'a design on your left foot', baseCost: 400, allowedTags: ['small', 'medium', 'geometric', 'watercolor', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] },
    'right_foot': { name: 'Right Foot Tattoo', baseDesign: 'a design on your right foot', baseCost: 400, allowedTags: ['small', 'medium', 'geometric', 'watercolor', 'color', 'none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'] }
};

const piercingTemplates = {
    standard_stud: {
        name: 'Stud',
        baseCost: 100,
        baseJewelry: 'a simple stud',
        allowedTags: [
            // Location tags (these are the actual body part IDs)
            'left_ear', 'right_ear', 'nose', 'lips', 'belly', 'left_nipple', 'right_nipple', 'vagina', 'tongue', 'face', 'anus',
            // Material tags
            'stainless steel', 'titanium', 'gold', 'silver', 'blackened steel',
            // Style tags
            'stud', 'ring', 'barbell', 'horseshoe'
        ]
    }
};

const tattooStyleTags = ['american traditional', 'neo traditional', 'tribal', 'watercolor', 'realism', 'japanese', 'geometric', 'lettering', 'minimalist', 'abstract'];
const tattooFeatureTags = ['blackwork', 'color', 'linework', 'dotwork', 'shading', 'uv-ink'];
const tattooSizeTags = ['tiny', 'small', 'medium', 'large', 'full-sleeve', 'full-back'];
const piercingMaterialTags = ['stainless steel', 'titanium', 'gold', 'silver', 'blackened steel'];
const piercingStyleTags = ['stud', 'ring', 'barbell', 'horseshoe'];
const tattooThemeTags = ['none', 'promiscuous', 'prostitution', 'exhibitionism', 'deviancy', 'masochism', 'submission', 'pregnancy'];

const bodyPartOrder = [
    'face', 'forehead', 'left_ear', 'right_ear', 'nose', 'lips', 'tongue', 'neck',
    'chest', 'belly', 'upper_back', 'lower_back',
    'left_arm', 'right_arm', 'left_wrist', 'right_wrist', 'left_hand', 'right_hand',
    'groin', 'vagina', 'anus', 'left_ass_cheek', 'right_ass_cheek',
    'left_thigh', 'right_thigh', 'left_calf', 'right_calf', 'left_ankle', 'right_ankle', 'left_foot', 'right_foot'
];

const tattooTagPrices = {
    // Styles
    'american traditional': 300, 'neo traditional': 350, 'tribal': 250, 'watercolor': 400, 'realism': 500, 'japanese': 450, 'geometric': 280, 'lettering': 200, 'minimalist': 150, 'abstract': 320,
    // Features
    'blackwork': 100, 'color': 250, 'linework': 50, 'dotwork': 180, 'shading': 120, 'uv-ink': 400,
    // Sizes
    'tiny': 50, 'small': 150, 'medium': 300, 'large': 500, 'full-sleeve': 2000, 'full-back': 3500,
    // Themes
    'promiscuous': 200, 'prostitution': 500, 'exhibitionism': 250, 'deviancy': 300, 'masochism': 350, 'submission': 400, 'pregnancy': 450
};


/* ==============================================================
   CLOTHING TEMPLATES
   ============================================================== */
const clothingTemplates = {
  // Head
  hat_fedora: { id: 'hat_fedora', name: 'Fedora', slot: 'head', layer: 'outer', covers: ['head'], tags: ['hat'], allowedTags: ['casual', 'formal', 'wool', 'cotton'] },
  hat_baseball_cap: { id: 'hat_baseball_cap', name: 'Baseball Cap', slot: 'head', layer: 'outer', covers: ['head'], tags: ['hat'], allowedTags: ['casual', 'athletic', 'cotton', 'denim'] },
  hat_beanie: { id: 'hat_beanie', name: 'Beanie', slot: 'head', layer: 'outer', covers: ['head'], tags: ['hat'], allowedTags: ['casual', 'cool', 'goth', 'wool', 'cotton'] },
  hat_sunhat: { id: 'hat_sunhat', name: 'Sun Hat', slot: 'head', layer: 'outer', covers: ['head'], tags: ['hat'], allowedTags: ['casual', 'cotton'] },
  hat_tophat: { id: 'hat_tophat', name: 'Top Hat', slot: 'head', layer: 'outer', covers: ['head'], tags: ['hat'], allowedTags: ['formal', 'sexy', 'goth', 'silk', 'leather', 'costume'] },
  hat_costume_horns: { id: 'hat_costume_horns', name: 'Costume Horns', slot: 'head', layer: 'outer', covers: ['head'], tags: ['hat', 'costume'], allowedTags: ['plastic', 'metal', 'leather'] },
  glasses_reading: { id: 'glasses_reading', name: 'Reading Glasses', slot: 'head', layer: 'outer', covers: ['face'], tags: ['glasses'], allowedTags: ['casual', 'business', 'formal', 'plastic', 'metal'] },
  glasses_sunglasses: { id: 'glasses_sunglasses', name: 'Sunglasses', slot: 'head', layer: 'outer', covers: ['face'], tags: ['glasses'], allowedTags: ['casual', 'cool', 'sexy', 'plastic', 'metal'] },
  headband: { id: 'headband', name: 'Headband', slot: 'head', layer: 'outer', covers: ['head'], tags: ['accessory'], allowedTags: ['casual', 'athletic', 'cotton', 'plastic', 'spandex', 'nylon', 'polyester'] },
  head_costume: { id: 'head_costume', name: 'Head Costume', slot: 'head', layer: 'outer', covers: ['head'], tags: ['hat', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk'] },

  // Neck
  neck_scarf: { id: 'neck_scarf', name: 'Scarf', slot: 'neck', layer: 'outer', covers: ['neck'], tags: ['accessory'], allowedTags: ['casual', 'cool', 'formal', 'cotton', 'wool', 'silk', 'polyester'] },
  neck_necklace: { id: 'neck_necklace', name: 'Necklace', slot: 'neck', layer: 'outer', covers: ['neck'], tags: ['accessory', 'jewelry'], allowedTags: ['casual', 'formal', 'sexy', 'goth', 'metal', 'plastic'] },
  neck_choker: { id: 'neck_choker', name: 'Choker', slot: 'neck', layer: 'skin', covers: ['neck'], tags: ['accessory', 'jewelry'], allowedTags: ['sexy', 'goth', 'fetish-wear', 'leather', 'lace', 'metal', 'plastic', 'vinyl', 'satin'] },
  neck_costume: { id: 'neck_costume', name: 'Neck Costume', slot: 'neck', layer: 'outer', covers: ['neck'], tags: ['accessory', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk'] },

  // Upper Body
  upper_bra: { id: 'upper_bra', name: 'Bra', slot: 'upper', layer: 'skin', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple'], tags: ['underwear'], allowedTags: ['sexy', 'fetish-wear', 'transparent', 'cotton', 'lace', 'satin', 'silk', 'spandex', 'leather', 'vinyl', 'nylon', 'polyester'], forcedTags: ['belly showing'] },
  upper_bikini_top: { id: 'upper_bikini_top', name: 'Bikini Top', slot: 'upper', layer: 'skin', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple'], tags: ['swimwear'], allowedTags: ['sexy', 'spandex', 'cotton', 'nylon', 'polyester'], forcedTags: ['belly showing', 'swimming', 'underwear'] },
  upper_one_piece_swimwear: { id: 'upper_one_piece_swimwear', name: 'One-piece Swimwear', slot: 'upper', layer: 'skin', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek'], tags: ['swimwear'], allowedTags: ['sexy', 'athletic', 'spandex', 'cotton', 'nylon', 'polyester', 'belly showing'], forcedTags: ['swimming', 'underwear'] },
  upper_tshirt: { id: 'upper_tshirt', name: 'T-shirt', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back'], tags: ['top'], allowedTags: ['casual', 'cool', 'goth', 'cotton', 'spandex', 'polyester'] },
  upper_shirt_buttondown: { id: 'upper_shirt_buttondown', name: 'Button-down Shirt', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['casual', 'formal', 'business', 'cotton', 'silk', 'denim', 'polyester'] },
  upper_shirt_buttondown_tshirt: { id: 'upper_shirt_buttondown_tshirt', name: 'Button-down T-shirt', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back'], tags: ['top'], allowedTags: ['casual', 'cool', 'cotton', 'spandex', 'polyester'] },
  upper_crop_top: { id: 'upper_crop_top', name: 'Crop Top', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'upper_back'], tags: ['top'], allowedTags: ['casual', 'cool', 'sexy', 'goth', 'cotton', 'spandex', 'lace', 'nylon', 'polyester', 'belly showing'], forcedTags: ['belly showing'] },
  upper_tank_top: { id: 'upper_tank_top', name: 'Tank Top', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back'], tags: ['top'], allowedTags: ['casual', 'athletic', 'sexy', 'cotton', 'spandex', 'nylon', 'polyester'] },
  upper_blouse: { id: 'upper_blouse', name: 'Blouse', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['casual', 'formal', 'business', 'sexy', 'cotton', 'silk', 'satin', 'lace', 'polyester'] },
  upper_sheer_blouse: { id: 'upper_sheer_blouse', name: 'Sheer Blouse', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top', 'transparent', 'fetish-wear'], allowedTags: ['formal', 'sexy', 'goth', 'silk', 'satin', 'lace', 'nylon', 'polyester', 'fishnet'] },
  upper_off_shoulder_blouse: { id: 'upper_off_shoulder_blouse', name: 'Off-shoulder Blouse', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['casual', 'formal', 'sexy', 'cotton', 'silk', 'satin', 'lace', 'polyester'] },
  upper_off_shoulder_crop_top: { id: 'upper_off_shoulder_crop_top', name: 'Off-shoulder Crop Top', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'upper_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['casual', 'sexy', 'goth', 'cotton', 'spandex', 'lace', 'polyester', 'belly showing'], forcedTags: ['belly showing'] },
  upper_halter_top: { id: 'upper_halter_top', name: 'Halter Top', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly'], tags: ['top'], allowedTags: ['casual', 'sexy', 'goth', 'cotton', 'spandex', 'leather', 'vinyl', 'nylon', 'polyester', 'belly showing'], forcedTags: ['belly showing'] },
  upper_corset: { id: 'upper_corset', name: 'Corset', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly'], tags: ['top'], allowedTags: ['formal', 'sexy', 'goth', 'fetish-wear', 'leather', 'lace', 'satin', 'denim', 'vinyl', 'costume', 'belly showing'], forcedTags: ['belly showing'] },
  upper_sweater: { id: 'upper_sweater', name: 'Sweater', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['casual', 'cool', 'goth', 'wool', 'cotton', 'polyester'] },
  upper_turtleneck_sweater: { id: 'upper_turtleneck_sweater', name: 'Turtleneck Sweater', slot: 'upper', layer: 'middle', covers: ['neck', 'chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['casual', 'formal', 'cool', 'goth', 'wool', 'cotton', 'polyester'] },
  upper_hoodie: { id: 'upper_hoodie', name: 'Hoodie', slot: 'upper', layer: 'outer', covers: ['head', 'chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['casual', 'athletic', 'cool', 'goth', 'cotton', 'wool', 'polyester'] },
  upper_hoodie_zipper: { id: 'upper_hoodie_zipper', name: 'Hoodie (zipper)', slot: 'upper', layer: 'outer', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm', 'head'], tags: ['top'], allowedTags: ['casual', 'athletic', 'cool', 'goth', 'cotton', 'wool', 'polyester'] },
  upper_jacket: { id: 'upper_jacket', name: 'Jacket', slot: 'upper', layer: 'outer', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['casual', 'cool', 'goth', 'leather', 'denim', 'wool', 'polyester'] },
  upper_coat: { id: 'upper_coat', name: 'Coat', slot: 'upper', layer: 'outer', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm', 'left_thigh', 'right_thigh'], tags: ['top'], allowedTags: ['casual', 'formal', 'goth', 'wool', 'leather', 'polyester'] },
  upper_blazer: { id: 'upper_blazer', name: 'Blazer', slot: 'upper', layer: 'outer', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top'], allowedTags: ['formal', 'business', 'sexy', 'cotton', 'wool', 'satin', 'polyester'] },
  upper_vest: { id: 'upper_vest', name: 'Vest', slot: 'upper', layer: 'outer', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back'], tags: ['top'], allowedTags: ['casual', 'formal', 'business', 'goth', 'cotton', 'wool', 'leather', 'denim', 'polyester'] },
  upper_apron: { id: 'upper_apron', name: 'Apron', slot: 'upper', layer: 'outer', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly'], tags: ['costume'], allowedTags: ['cotton', 'costume'] },
  upper_dress_short: { id: 'upper_dress_short', name: 'Short Dress', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek'], tags: ['dress'], allowedTags: ['casual', 'formal', 'sexy', 'goth', 'cotton', 'silk', 'satin', 'lace', 'denim', 'leather', 'vinyl', 'polyester', 'belly showing'] },
  upper_dress_medium: { id: 'upper_dress_medium', name: 'Medium Dress', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh'], tags: ['dress'], allowedTags: ['casual', 'formal', 'sexy', 'goth', 'cotton', 'silk', 'satin', 'lace', 'denim', 'wool', 'polyester', 'belly showing'] },
  upper_dress_long: { id: 'upper_dress_long', name: 'Long Dress', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['dress'], allowedTags: ['formal', 'sexy', 'goth', 'cotton', 'silk', 'satin', 'lace', 'wool', 'polyester', 'belly showing'] },
  upper_leotard: { id: 'upper_leotard', name: 'Leotard', slot: 'upper', layer: 'middle', covers: ['chest', 'left_breast', 'right_breast', 'left_nipple', 'right_nipple', 'belly', 'upper_back', 'lower_back', 'groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek'], tags: ['top', 'fetish-wear'], allowedTags: ['sexy', 'athletic', 'goth', 'nylon', 'polyester', 'spandex', 'vinyl', 'leather', 'lace'] },
  upper_costume: { id: 'upper_costume', name: 'Upper Body Costume', slot: 'upper', layer: 'outer', covers: ['chest', 'belly', 'upper_back', 'lower_back', 'left_arm', 'right_arm'], tags: ['top', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk', 'spandex'] },

  // Waist
  waist_belt: { id: 'waist_belt', name: 'Belt', slot: 'waist', layer: 'outer', covers: ['waist'], tags: ['accessory'], allowedTags: ['casual', 'formal', 'business', 'goth', 'sexy', 'leather', 'metal', 'plastic', 'vinyl'] },
  waist_sash_wrap: { id: 'waist_sash_wrap', name: 'Sash Wrap', slot: 'waist', layer: 'outer', covers: ['waist'], tags: ['accessory'], allowedTags: ['casual', 'formal', 'sexy', 'silk', 'satin', 'cotton'] },
  waist_corset: { id: 'waist_corset', name: 'Waist Corset', slot: 'waist', layer: 'middle', covers: ['belly', 'waist'], tags: ['accessory'], allowedTags: ['sexy', 'goth', 'fetish-wear', 'leather', 'lace', 'satin', 'denim', 'vinyl', 'costume'] },
  waist_apron: { id: 'waist_apron', name: 'Waist Apron', slot: 'waist', layer: 'outer', covers: ['groin', 'waist'], tags: ['costume'], allowedTags: ['cotton', 'costume'] },
  waist_costume: { id: 'waist_costume', name: 'Waist Costume', slot: 'waist', layer: 'outer', covers: ['waist'], tags: ['accessory', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk'] },

  // Lower Body
  lower_panties: { id: 'lower_panties', name: 'Panties', slot: 'lower', layer: 'skin', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek'], tags: ['underwear'], allowedTags: ['sexy', 'fetish-wear', 'transparent', 'cotton', 'lace', 'satin', 'silk', 'spandex', 'leather', 'vinyl', 'nylon', 'polyester'] },
  lower_bikini_bottoms: { id: 'lower_bikini_bottoms', name: 'Bikini Bottoms', slot: 'lower', layer: 'skin', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek'], tags: ['swimwear'], allowedTags: ['sexy', 'spandex', 'cotton', 'nylon', 'polyester'], forcedTags: ['swimming', 'underwear'] },
  lower_jeans: { id: 'lower_jeans', name: 'Jeans', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['pants'], allowedTags: ['casual', 'cool', 'goth', 'sexy', 'denim'] },
  lower_pants: { id: 'lower_pants', name: 'Pants', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['pants'], allowedTags: ['casual', 'formal', 'business', 'goth', 'cotton', 'wool', 'spandex', 'leather', 'polyester'] },
  lower_leggings: { id: 'lower_leggings', name: 'Leggings', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['pants'], allowedTags: ['casual', 'athletic', 'sexy', 'goth', 'cotton', 'spandex', 'leather', 'vinyl', 'nylon', 'polyester'] },
  lower_sweatpants: { id: 'lower_sweatpants', name: 'Sweatpants', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['pants'], allowedTags: ['casual', 'athletic', 'cotton', 'polyester'] },
  lower_shorts: { id: 'lower_shorts', name: 'Shorts', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh'], tags: ['shorts'], allowedTags: ['casual', 'athletic', 'sexy', 'cotton', 'denim', 'spandex', 'leather', 'nylon', 'polyester'] },
  lower_mini_shorts: { id: 'lower_mini_shorts', name: 'Mini Shorts', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek'], tags: ['shorts'], allowedTags: ['casual', 'sexy', 'goth', 'cotton', 'denim', 'spandex', 'leather', 'vinyl', 'nylon', 'polyester'] },
  lower_skirt_long: { id: 'lower_skirt_long', name: 'Long Skirt', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['skirt'], allowedTags: ['casual', 'formal', 'goth', 'cotton', 'denim', 'wool', 'satin', 'silk', 'leather', 'polyester'] },
  lower_skirt: { id: 'lower_skirt', name: 'Skirt', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh'], tags: ['skirt'], allowedTags: ['casual', 'formal', 'business', 'sexy', 'goth', 'cotton', 'denim', 'wool', 'satin', 'leather', 'polyester'] },
  lower_skirt_short: { id: 'lower_skirt_short', name: 'Short Skirt', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh'], tags: ['skirt'], allowedTags: ['casual', 'sexy', 'goth', 'cotton', 'denim', 'wool', 'satin', 'leather', 'vinyl', 'polyester'] },
  lower_mini_skirt: { id: 'lower_mini_skirt', name: 'Mini Skirt', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek'], tags: ['skirt'], allowedTags: ['casual', 'sexy', 'goth', 'fetish-wear', 'cotton', 'denim', 'satin', 'leather', 'vinyl', 'lace', 'costume'] },
  lower_cargo_pants: { id: 'lower_cargo_pants', name: 'Cargo Pants', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['pants'], allowedTags: ['casual', 'cotton', 'denim', 'polyester'] },
  lower_costume: { id: 'lower_costume', name: 'Lower Body Costume', slot: 'lower', layer: 'middle', covers: ['groin', 'vagina', 'anus', 'butt', 'left_ass_cheek', 'right_ass_cheek', 'left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['pants', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk', 'spandex'] },

  // Legs
  legs_legwarmers: { id: 'legs_legwarmers', name: 'Legwarmers', slot: 'legs', layer: 'middle', covers: ['left_calf', 'right_calf'], tags: ['accessory'], allowedTags: ['goth', 'cool', 'casual', 'wool', 'cotton', 'polyester'] },
  legs_socks: { id: 'legs_socks', name: 'Socks', slot: 'legs', layer: 'skin', covers: ['left_foot', 'right_foot', 'left_ankle', 'right_ankle'], tags: ['hosiery'], allowedTags: ['casual', 'athletic', 'formal', 'cotton', 'wool', 'spandex', 'nylon', 'polyester'] },
  legs_thigh_high_socks: { id: 'legs_thigh_high_socks', name: 'Thigh High Socks', slot: 'legs', layer: 'skin', covers: ['left_foot', 'right_foot', 'left_calf', 'right_calf', 'left_thigh', 'right_thigh', 'left_ankle', 'right_ankle'], tags: ['hosiery'], allowedTags: ['sexy', 'goth', 'cotton', 'wool', 'spandex', 'lace', 'nylon', 'polyester', 'fishnet'] },
  legs_stockings: { id: 'legs_stockings', name: 'Stockings', slot: 'legs', layer: 'skin', covers: ['left_foot', 'right_foot', 'left_calf', 'right_calf', 'left_thigh', 'right_thigh', 'left_ankle', 'right_ankle'], tags: ['hosiery'], allowedTags: ['sexy', 'formal', 'goth', 'fetish-wear', 'spandex', 'lace', 'vinyl', 'nylon', 'fishnet'] },
  legs_tights: { id: 'legs_tights', name: 'Tights', slot: 'legs', layer: 'skin', covers: ['left_foot', 'right_foot', 'left_calf', 'right_calf', 'left_thigh', 'right_thigh', 'butt', 'waist', 'left_ankle', 'right_ankle'], tags: ['hosiery'], allowedTags: ['sexy', 'formal', 'goth', 'fetish-wear', 'spandex', 'lace', 'vinyl', 'wool', 'cotton', 'nylon', 'polyester', 'fishnet', 'costume'] },
  legs_costume: { id: 'legs_costume', name: 'Legs Costume', slot: 'legs', layer: 'middle', covers: ['left_thigh', 'right_thigh', 'left_calf', 'right_calf'], tags: ['hosiery', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk', 'spandex'] },

  // Arms
  arms_detached_sleeves: { id: 'arms_detached_sleeves', name: 'Detached Sleeves', slot: 'arms', layer: 'middle', covers: ['left_arm', 'right_arm'], tags: ['accessory'], allowedTags: ['goth', 'sexy', 'cool', 'lace', 'spandex', 'cotton', 'leather', 'vinyl', 'nylon', 'polyester', 'fishnet'] },
  arms_arm_warmers: { id: 'arms_arm_warmers', name: 'Arm Warmers', slot: 'arms', layer: 'middle', covers: ['left_arm', 'right_arm'], tags: ['accessory'], allowedTags: ['goth', 'cool', 'casual', 'wool', 'cotton', 'spandex', 'nylon', 'polyester'] },
  arms_wristbands: { id: 'arms_wristbands', name: 'Wristbands', slot: 'arms', layer: 'outer', covers: ['left_wrist', 'right_wrist'], tags: ['accessory'], allowedTags: ['athletic', 'goth', 'cool', 'casual', 'cotton', 'leather', 'plastic'] },
  arms_armbands: { id: 'arms_armbands', name: 'Armbands', slot: 'arms', layer: 'outer', covers: ['left_arm', 'right_arm'], tags: ['accessory'], allowedTags: ['athletic', 'goth', 'cool', 'sexy', 'metal', 'leather', 'plastic'] },
  arms_costume: { id: 'arms_costume', name: 'Arms Costume', slot: 'arms', layer: 'middle', covers: ['left_arm', 'right_arm'], tags: ['accessory', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk', 'spandex'] },

  // Hands
  hands_gloves: { id: 'hands_gloves', name: 'Gloves', slot: 'hands', layer: 'outer', covers: ['left_hand', 'right_hand'], tags: ['accessory'], allowedTags: ['formal', 'goth', 'sexy', 'fetish-wear', 'leather', 'lace', 'satin', 'cotton', 'spandex', 'vinyl', 'nylon', 'polyester'] },
  hands_watches: { id: 'hands_watches', name: 'Watches', slot: 'hands', layer: 'outer', covers: ['left_wrist'], tags: ['accessory', 'jewelry'], allowedTags: ['formal', 'business', 'casual', 'athletic', 'sexy', 'metal'] },
  hands_bracelets: { id: 'hands_bracelets', name: 'Bracelets', slot: 'hands', layer: 'outer', covers: ['left_wrist', 'right_wrist'], tags: ['accessory', 'jewelry'], allowedTags: ['goth', 'sexy', 'casual', 'metal', 'leather', 'plastic'] },
  hands_rings: { id: 'hands_rings', name: 'Rings', slot: 'hands', layer: 'outer', covers: ['left_hand', 'right_hand'], tags: ['accessory', 'jewelry'], allowedTags: ['formal', 'goth', 'sexy', 'casual', 'metal'] },
  hands_costume: { id: 'hands_costume', name: 'Hands Costume', slot: 'hands', layer: 'outer', covers: ['left_hand', 'right_hand'], tags: ['accessory', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk', 'spandex'] },

  // Feet
  feet_ankle_cuffs: { id: 'feet_ankle_cuffs', name: 'Ankle Cuffs', slot: 'feet', layer: 'outer', covers: ['left_ankle', 'right_ankle'], tags: ['accessory'], allowedTags: ['sexy', 'goth', 'fetish-wear', 'leather', 'metal', 'lace'] },
  feet_anklets: { id: 'feet_anklets', name: 'Anklets', slot: 'feet', layer: 'outer', covers: ['left_ankle', 'right_ankle'], tags: ['accessory', 'jewelry'], allowedTags: ['sexy', 'casual', 'goth', 'metal', 'plastic'] },
  feet_loafers: { id: 'feet_loafers', name: 'Loafers', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'formal', 'business', 'leather'] },
  feet_ballet_flats: { id: 'feet_ballet_flats', name: 'Ballet Flats', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'formal', 'leather', 'satin'] },
  feet_mary_janes: { id: 'feet_mary_janes', name: 'Mary Janes', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'formal', 'goth', 'sexy', 'leather', 'vinyl'] },
  feet_boots: { id: 'feet_boots', name: 'Boots', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot', 'left_calf', 'right_calf'], tags: ['shoes'], allowedTags: ['casual', 'formal', 'goth', 'cool', 'leather', 'vinyl', 'costume'] },
  feet_platform_boots: { id: 'feet_platform_boots', name: 'Platform Boots', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot', 'left_calf', 'right_calf'], tags: ['shoes'], allowedTags: ['goth', 'fetish-wear', 'sexy', 'leather', 'vinyl'], forcedTags: ['high heeled'] },
  feet_sandals: { id: 'feet_sandals', name: 'Sandals', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'leather', 'plastic'] },
  feet_slippers: { id: 'feet_slippers', name: 'Slippers', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'cotton', 'wool'] },
  feet_flip_flops: { id: 'feet_flip_flops', name: 'Flip-flops', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'plastic'] },
  feet_running_shoes: { id: 'feet_running_shoes', name: 'Running Shoes', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'athletic', 'plastic', 'spandex', 'nylon', 'polyester'] },
  feet_high_top_sneakers: { id: 'feet_high_top_sneakers', name: 'High-top Sneakers', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'cool', 'athletic', 'cotton', 'leather'] },
  feet_sneakers: { id: 'feet_sneakers', name: 'Sneakers', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['casual', 'cool', 'athletic', 'cotton', 'leather'] },
  feet_pumps: { id: 'feet_pumps', name: 'Pumps', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['formal', 'business', 'sexy', 'leather', 'satin', 'vinyl', 'costume'], forcedTags: ['high heeled'] },
  feet_heels: { id: 'feet_heels', name: 'Heels', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes'], allowedTags: ['formal', 'sexy', 'fetish-wear', 'leather', 'satin', 'vinyl', 'plastic', 'metal', 'costume'], forcedTags: ['high heeled'] },
  feet_costume: { id: 'feet_costume', name: 'Feet Costume', slot: 'feet', layer: 'outer', covers: ['left_foot', 'right_foot'], tags: ['shoes', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk'] },

  // Back
  back_backpack: { id: 'back_backpack', name: 'Backpack', slot: 'back', layer: null, covers: [], tags: ['bag'], allowedTags: ['casual', 'athletic', 'cool', 'cotton', 'denim', 'leather'] },
  back_costume: { id: 'back_costume', name: 'Back Costume', slot: 'back', layer: null, covers: [], tags: ['bag', 'costume'], allowedTags: ['plastic', 'metal', 'leather', 'cotton', 'wool', 'silk'] },

  // Hand-held
  handheld_handbag: { id: 'handheld_handbag', name: 'Handbag', slot: 'hand-held', layer: null, covers: [], tags: ['bag'], allowedTags: ['casual', 'formal', 'sexy', 'leather', 'satin', 'vinyl'] },
};

/* ==============================================================
   BODY PART DESCRIPTORS
   ============================================================== */
const bodyPartDescriptors = {
  // Female Descriptors
  breasts: ['flat', 'tiny', 'small', 'pert', 'modest', 'ample', 'large', 'heavy', 'massive', 'huge'],
  nipples: ['inverted', 'tiny', 'small', 'puffy', 'protruding', 'large'],
  vagina: ['very tight', 'tight', 'snug', 'loose', 'gaping'],
  // Male Descriptors
  penis: ['tiny', 'small', 'slender', 'average', 'thick', 'large', 'huge', 'massive'],
  // Universal Descriptors
  face: ['soft', 'oval', 'round', 'heart-shaped', 'delicate', 'chiseled', 'freckled'],
  eyes: ['almond-shaped', 'round', 'upturned', 'large', 'doe-eyed', 'soulful', 'bright'],
  lips: ['thin', 'slender', 'average', 'full', 'plump', 'pillowy'],
  arms: ['thin', 'slender', 'average', 'thick', 'burly'],
  hands: ['tiny', 'small', 'delicate', 'average-sized', 'large', 'huge'],
  belly: ['washboard', 'flat', 'soft', 'pudgy', 'pot-bellied', 'bloated'],
  buttocks: ['flat', 'small', 'pert', 'rounded', 'large', 'ample', 'huge'],
  thighs: ['thin', 'slender', 'average', 'sturdy', 'thick', 'massive'],
  calves: ['thin', 'slender', 'average', 'strong', 'thick'],
  feet: ['tiny', 'small', 'dainty', 'average-sized', 'large', 'huge'],
};

// Define which descriptors are gender-specific to allow for filtering
const femaleOnlyDescriptors = ['breasts', 'nipples', 'vagina'];
const maleOnlyDescriptors = ['penis'];

/* ==============================================================
   PALETTE UTILITIES (SHARED)
   ============================================================== */
const paletteUtils = {
    hexToRgb(hex) {
        let r = 0, g = 0, b = 0;
        if (hex.length == 4) {
            r = "0x" + hex[1] + hex[1];
            g = "0x" + hex[2] + hex[2];
            b = "0x" + hex[3] + hex[3];
        } else if (hex.length == 7) {
            r = "0x" + hex[1] + hex[2];
            g = "0x" + hex[3] + hex[4];
            b = "0x" + hex[5] + hex[6];
        }
        return { r: +r, g: +g, b: +b };
    },
    rgbToHex(r, g, b) {
        r = Math.round(r).toString(16);
        g = Math.round(g).toString(16);
        b = Math.round(b).toString(16);
        if (r.length == 1) r = "0" + r;
        if (g.length == 1) g = "0" + g;
        if (b.length == 1) b = "0" + b;
        return "#" + r + g + b;
    },
    interpolateLinear(start, end, factor) {
        return start + (end - start) * factor;
    },
    interpolateRgb(color1, color2, factor) {
        const r = this.interpolateLinear(color1.r, color2.r, factor);
        const g = this.interpolateLinear(color1.g, color2.g, factor);
        const b = this.interpolateLinear(color1.b, color2.b, factor);
        return { r, g, b };
    },
    mapIdsToCoords(shape) {
        const coordMap = new Map();
        let id = 1;
        const numRows = shape.length;
        const r_offset = Math.floor(numRows / 2);

        for (let i = 0; i < numRows; i++) {
            const rowSize = shape[i];
            const r = i - r_offset;
            const q_start = -Math.floor(rowSize / 2) + (rowSize % 2 === 0 ? 0 : 0);
            for (let j = 0; j < rowSize; j++) {
                let q = q_start + j;
                if (rowSize % 2 === 0 && q >= 0) {
                    q += 1;
                }
                coordMap.set(id++, { q, r });
            }
        }
        return coordMap;
    },
    getAxialDistance(coord1, coord2) {
        return (Math.abs(coord1.q - coord2.q)
              + Math.abs(coord1.q + coord1.r - coord2.q - coord2.r)
              + Math.abs(coord1.r - coord2.r)) / 2;
    }
};

/* ==============================================================
   NATURAL HAIR PALETTE GENERATOR
   ============================================================== */
const naturalHairPaletteGenerator = {
    // --- Main Generator Function ---
    generate() {
        const shape = [6, 7, 8, 9, 10, 11, 10, 9, 8, 7, 6];
        const totalSlots = shape.reduce((a, b) => a + b, 0);
        const coordMap = paletteUtils.mapIdsToCoords(shape);
        const palette = new Array(totalSlots).fill(null);

        const regions = {
            blonde: {
                name: 'Blonde',
                center: { q: -4, r: -2 },
                light: paletteUtils.hexToRgb('#FCF6D5'), // Platinum Blonde
                dark: paletteUtils.hexToRgb('#A5833B')   // Darkest Dirty Blonde
            },
            brown: {
                name: 'Brown',
                center: { q: 4, r: -2 },
                light: paletteUtils.hexToRgb('#B58A6F'), // Warmer Light Brown
                dark: paletteUtils.hexToRgb('#2F0F05')   // Darkest Reddish Brown
            },
            red: {
                name: 'Red',
                center: { q: -4, r: 3 },
                light: paletteUtils.hexToRgb('#D38D5F'), // Strawberry Blonde
                dark: paletteUtils.hexToRgb('#3D0D00')   // Deepest Auburn
            },
            black: {
                name: 'Black/Gray',
                center: { q: 4, r: 3 },
                light: paletteUtils.hexToRgb('#505050'), // Dark Gray
                dark: paletteUtils.hexToRgb('#010101')   // Near Black
            }
        };

        const maxDist = 5.5; // Max distance for interpolation scaling

        for (let id = 1; id <= totalSlots; id++) {
            const coord = coordMap.get(id);

            // Find closest region
            let closestRegionName = null;
            let minDistance = Infinity;
            for (const regionName in regions) {
                const distance = paletteUtils.getAxialDistance(coord, regions[regionName].center);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestRegionName = regionName;
                }
            }

            const region = regions[closestRegionName];

            // Calculate interpolation factor based on distance from the region's center
            // Clamp factor between 0 and 1
            const factor = Math.min(1, minDistance / maxDist);

            const finalRgb = paletteUtils.interpolateRgb(region.light, region.dark, factor);
            const finalHex = paletteUtils.rgbToHex(finalRgb.r, finalRgb.g, finalRgb.b);

            // Generate a name
            let colorName = '';
            if (factor < 0.33) colorName = 'Light ';
            else if (factor > 0.66) colorName = 'Dark ';
            colorName += region.name.split('/')[0]; // Use "Black" from "Black/Gray"

            palette[id - 1] = { name: colorName, hex: finalHex };
        }

        return palette;
    }
};

/* ==============================================================
   NATURAL EYE PALETTE GENERATOR
   ============================================================== */
const naturalEyePaletteGenerator = {
    // --- Main Generator ---
    generate() {
        const shape = [6, 7, 8, 9, 10, 11, 10, 9, 8, 7, 6];
        const coordMap = paletteUtils.mapIdsToCoords(shape);
        const palette = new Array(shape.reduce((a, b) => a + b, 0)).fill(null);

        const regions = {
            blue:   { name: 'Blue',   center: { q: 0, r: -3 }, light: paletteUtils.hexToRgb('#ADD8E6'), dark: paletteUtils.hexToRgb('#00004B') },
            brown:  { name: 'Brown',  center: { q: 5,  r: 0 }, light: paletteUtils.hexToRgb('#B8860B'), dark: paletteUtils.hexToRgb('#452301') },
            green:  { name: 'Green',  center: { q: 0,  r: 3 },  light: paletteUtils.hexToRgb('#98FB98'), dark: paletteUtils.hexToRgb('#002400') },
            // rare region is manually placed, so we use the 4th quadrant for hazel
            hazel:  { name: 'Hazel',  center: { q: -5, r: 0 },  light: paletteUtils.hexToRgb('#D3D3D3'), dark: paletteUtils.hexToRgb('#354B0F') }
        };
        const maxDist = 5.5;

        for (let id = 1; id <= palette.length; id++) {
            const coord = coordMap.get(id);
            let closestRegionName = null;
            let minDistance = Infinity;
            for (const regionName in regions) {
                const distance = paletteUtils.getAxialDistance(coord, regions[regionName].center);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestRegionName = regionName;
                }
            }
            const region = regions[closestRegionName];
            const factor = Math.min(1, minDistance / maxDist);
            const finalRgb = paletteUtils.interpolateRgb(region.light, region.dark, factor);

            let colorName = '';
            if (factor < 0.33) colorName = 'Light ';
            else if (factor > 0.66) colorName = 'Dark ';
            palette[id - 1] = { name: colorName + region.name, hex: paletteUtils.rgbToHex(finalRgb.r, finalRgb.g, finalRgb.b) };
        }

        // Manually overwrite hexes for the 3x3 rare colors
        // Amber shades
        palette[70] = { name: 'Light Amber', hex: '#FFD700' }; // ID 71
        palette[71] = { name: 'Amber', hex: '#FFBF00' };       // ID 72
        palette[72] = { name: 'Dark Amber', hex: '#B8860B' };  // ID 73
        // Crimson shades
        palette[78] = { name: 'Light Crimson', hex: '#F08080' };// ID 79
        palette[79] = { name: 'Crimson', hex: '#DC143C' };      // ID 80
        palette[80] = { name: 'Dark Crimson', hex: '#8B0000' }; // ID 81
        // Violet shades
        palette[85] = { name: 'Light Violet', hex: '#D8BFD8' }; // ID 86
        palette[86] = { name: 'Violet', hex: '#9932CC' };       // ID 87
        palette[87] = { name: 'Dark Violet', hex: '#4B0082' };  // ID 88

        return palette;
    }
};

/* ==============================================================
   PALETTE GENERATOR
   ============================================================== */
// Note: A block of helper functions to programmatically generate the complex 91-color hexagonal palette.
// This ensures the color logic is maintainable and accurate.

const unnaturalPaletteGenerator = {
    // --- Color Naming ---
    getColorName(h, s, l) {
        let name = '';
        // Handle grayscales first, as they have low saturation
        if (s < 0.15) {
            if (l > 0.95) return 'White';
            if (l < 0.05) return 'Black';
            if (l < 0.3) return 'Dark Gray';
            if (l > 0.7) return 'Light Gray';
            return 'Gray';
        }

        // Add lightness descriptors
        if (l > 0.8) name += 'Pale ';
        else if (l < 0.3) name += 'Dark ';

        // Add saturation/vibrancy descriptors
        if (s > 0.8 && l >= 0.4 && l <= 0.6) name += 'Vivid ';

        // Determine the base hue name
        const hue = h * 360;
        if (hue < 15) name += 'Red';
        else if (hue < 35) name += 'Orange';
        else if (hue < 60) name += 'Yellow';
        else if (hue < 90) name += 'Lime';
        else if (hue < 150) name += 'Green';
        else if (hue < 210) name += 'Cyan';
        else if (hue < 255) name += 'Blue';
        else if (hue < 285) name += 'Purple';
        else if (hue < 335) name += 'Magenta';
        else name += 'Red'; // Wrap around

        return name.trim();
    },

    // --- Color Conversion Utilities ---
    rgbToHsl(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max == min) {
            h = s = 0;
        } else {
            let d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h, s, l };
    },
    hslToRgb(h, s, l) {
        let r, g, b;
        if (s == 0) {
            r = g = b = l;
        } else {
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            }
            let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            let p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return { r: r * 255, g: g * 255, b: b * 255 };
    },

    // --- Main Generator Function ---
    generate() {
        const shape = [6, 7, 8, 9, 10, 11, 10, 9, 8, 7, 6];
        const totalSlots = shape.reduce((a, b) => a + b, 0);
        const coordMap = paletteUtils.mapIdsToCoords(shape);
        const centerCoord = { q: 0, r: 0 };
        const palette = new Array(totalSlots).fill(null);

        // Define the 6 corner hues AND their angular positions (in degrees)
        // This layout matches the user's request: Red(right), Green(top-left), Blue(bottom-left)
        const corners = [
            { name: 'Red',     h: 0,     s: 1, l: 0.5, angle: 0 },
            { name: 'Yellow',  h: 1/6,   s: 1, l: 0.5, angle: 60 },
            { name: 'Green',   h: 1/3,   s: 1, l: 0.5, angle: 125 },
            { name: 'Cyan',    h: 1/2,   s: 1, l: 0.5, angle: 180 },
            { name: 'Blue',    h: 2/3,   s: 1, l: 0.5, angle: 240 },
            { name: 'Magenta', h: 5/6,   s: 1, l: 0.5, angle: 300 }
        ];
        
        // Generate colors for each slot
        for (let id = 1; id <= totalSlots; id++) {
            const coord = coordMap.get(id);
            const ring = paletteUtils.getAxialDistance(coord, centerCoord);

            // Handle colors
            // 1. Calculate angle of the current hexagon in degrees (0-360)
            // We convert from axial coordinates (q, r) to cartesian (x, y) to get the angle.
            // The y-axis for atan2 is positive upwards, while our r-coordinate is positive downwards, so we use -r.
            const x_cart = Math.sqrt(3) * coord.q + Math.sqrt(3) / 2 * coord.r;
            const y_cart = -(3 / 2 * coord.r);
            let angle = Math.atan2(y_cart, x_cart) * 180 / Math.PI;
            if (angle < 0) angle += 360;

            // 2. Find the two corners the angle is between
            let c1, c2;
            for (let i = 0; i < corners.length; i++) {
                c1 = corners[i];
                c2 = corners[(i + 1) % corners.length];
                let angle1 = c1.angle;
                let angle2 = c2.angle;
                if (angle2 < angle1) angle2 += 360; // Handle wrap-around for Red (300 -> 0 becomes 300 -> 360)

                if (angle >= angle1 && angle <= angle2) {
                    break;
                }
            }

            // 3. Calculate interpolation factor
            let angle1 = c1.angle;
            let angle2 = c2.angle;
            if (angle2 < angle1) angle2 += 360;
            // Avoid division by zero if angles are the same
            const factor = (angle2 - angle1 === 0) ? 0 : (angle - angle1) / (angle2 - angle1);

            // 4. Interpolate hue using the shortest path logic
            const h1 = c1.h;
            const h2 = c2.h;
            let diff = h2 - h1;
            if (diff > 0.5) diff -= 1;
            if (diff < -0.5) diff += 1;
            const finalH = (h1 + diff * factor + 1) % 1;

            // 5. Interpolate lightness based on ring distance in a non-linear fashion
            const finalS = 1.0;
            let finalL;
            if (ring <= 3) {
                // From ring 1 (L=0.9) to ring 3 (L=0.5)
                finalL = paletteUtils.interpolateLinear(0.9, 0.5, (ring - 1) / 2);
            } else {
                // From ring 3 (L=0.5) to ring 5 (L=0.2)
                finalL = paletteUtils.interpolateLinear(0.5, 0.33, (ring - 3) / 2);
            }

            const {r, g, b} = this.hslToRgb(finalH, finalS, finalL);
            const colorName = this.getColorName(finalH, finalS, finalL);
            palette[id - 1] = { name: colorName, hex: paletteUtils.rgbToHex(r, g, b) };
        }

        // Manually set the center hex (ID 46) to white to act as the grayscale picker button
        palette[45] = { name: 'Grays...', hex: '#FFFFFF' };
        
        return palette;
    }
};

const colorPalettes = {
    skin: {
        "Pale": ["#F2E5D9", "#F0D4C2", "#E8BEAC"],
        "Tan": ["#C68642", "#B87333", "#A48B70"],
        "Brown": ["#8D5524", "#6D4C41", "#5D4037"],
        "Dark": ["#4E342E", "#3B2F2F", "#2C170E"]
    },
    hair: {
        natural: naturalHairPaletteGenerator.generate(),
        unnatural: unnaturalPaletteGenerator.generate()
    },
    eyes: {
        natural: naturalEyePaletteGenerator.generate(),
        unnatural: unnaturalPaletteGenerator.generate()
    }
};

/* ==============================================================
   CLOTHING HELPERS
   ============================================================== */
function processClothingRules() {
    for (const id in clothingTemplates) {
        const template = clothingTemplates[id];

        // Ensure forcedTags and allowedTags exist to prevent errors
        if (!template.forcedTags) {
            template.forcedTags = [];
        }
        if (!template.allowedTags) {
            template.allowedTags = [];
        }
        
        // RULE 1: Automatically add 'belly hiding' if the item covers the belly
        // and is not explicitly a 'belly showing' optional item.
        if (template.covers && template.covers.includes('belly')) {
            const isBellyShowingOptional = template.allowedTags.includes('belly showing');
            if (!isBellyShowingOptional) {
                if (!template.forcedTags.includes('belly hiding')) {
                    template.forcedTags.push('belly hiding');
                }
            }
        }

        // RULE 2: If an item has only one material option, force it.
        const templateMaterials = template.allowedTags.filter(t => materialTags.includes(t));
        if (templateMaterials.length === 1) {
            const material = templateMaterials[0];
            // Move from allowed to forced
            const index = template.allowedTags.indexOf(material);
            if (index > -1) {
                template.allowedTags.splice(index, 1);
            }
            if (!template.forcedTags.includes(material)) {
                template.forcedTags.push(material);
            }
        }
    }
}

function updateCharDesc() {
    const descEl = document.getElementById('charDesc');
    const coverageMap = getCoverageInfo(); // This is the key
    const purple = 'purple';
    const red = '#ff4d4d';

    const formatItemName = (item, isOuter) => {
        if (!item) return '';
        if (isOuter && item.tags.includes('underwear')) {
            return `<span style="color: ${purple};">${item.name}</span>`;
        }
        return item.name;
    };

    const upperSlot = state.equipment.upper;
    const lowerSlot = state.equipment.lower;

    const upperVisible = upperSlot.outer || upperSlot.middle || upperSlot.skin;
    const lowerVisible = lowerSlot.outer || lowerSlot.middle || lowerSlot.skin;

    // --- Part 1: Determine what is being worn visibly ---
    const clothingParts = [];
    if (upperVisible) {
        clothingParts.push(formatItemName(upperVisible, true));
    }
    // Only add the lower item to the description if it's not covered by the upper item.
    const upperCoversGroin = upperVisible && upperVisible.covers.includes('groin');
    if (!upperCoversGroin && lowerVisible) {
        clothingParts.push(formatItemName(lowerVisible, true));
    }

    // --- Part 2: Determine what parts are exposed ---
    const exposureParts = [];
    // Use the coverage map for accurate exposure checks
    if (!coverageMap.has('left_breast')) { // Check one breast as a proxy for both
        const breastDescText = state.playerBody.left_breast.descriptor ? `${state.playerBody.left_breast.descriptor} ` : '';
        exposureParts.push(`Your ${breastDescText}breasts are exposed!`);
    }
    if (!coverageMap.has('vagina')) {
        const vaginaDescText = state.playerBody.vagina.descriptor ? `${state.playerBody.vagina.descriptor} ` : '';
        exposureParts.push(`Your ${vaginaDescText}vagina is exposed!`);
    }

    // --- Part 3: Construct the final description ---

    // Handle completely naked case
    if (clothingParts.length === 0 && exposureParts.length > 0) {
        descEl.innerHTML = `<span style="color: ${red};">You are completely naked!</span>`;
        return;
    }

    // 1. Start with the "wearing" part.
    let finalDesc = `You are wearing ${clothingParts.join(' and ')}`;

    // 2. Append the "underneath" part.
    const actuallyUnderUpper = upperSlot.skin && upperSlot.skin.tags.includes('underwear') && (upperSlot.middle || upperSlot.outer);
    const actuallyUnderLower = lowerSlot.skin && lowerSlot.skin.tags.includes('underwear') && (lowerSlot.middle || lowerSlot.outer);

    const underPartsToShow = [];
    if (actuallyUnderUpper) {
        underPartsToShow.push(upperSlot.skin);
    }
    if (actuallyUnderLower) {
        underPartsToShow.push(lowerSlot.skin);
    }
    const finalUnderParts = [...new Set(underPartsToShow)];

    const upperSkinNonUnderwear = upperSlot.skin && !upperSlot.skin.tags.includes('underwear');
    const lowerSkinNonUnderwear = lowerSlot.skin && !lowerSlot.skin.tags.includes('underwear');
    const hasAnyOuterwear = upperSlot.middle || upperSlot.outer || lowerSlot.middle || lowerSlot.outer || upperSkinNonUnderwear || lowerSkinNonUnderwear;

    if (hasAnyOuterwear) {
        if (finalUnderParts.length > 0) {
            finalDesc += ` with ${finalUnderParts.map(item => formatItemName(item, false)).join(' and ')} underneath`;
        } else {
            finalDesc += ` with <span style="color: ${purple};">nothing</span> underneath`;
        }
    }
    finalDesc += '.';

    // 3. Append the "exposure" part as a new sentence.
    if (exposureParts.length > 0) {
        finalDesc += ` <span style="color: ${red};">${exposureParts.join(' ')}</span>`;
    }

    // --- Part 4: Add Semen Descriptions ---
    if (state.bodyFluids) {
        const semenDescParts = [];
        const bodySemen = state.bodyFluids.body.semen.reduce((acc, s) => acc + s.volume, 0);
        const vaginaSemen = state.bodyFluids.vagina.semen.reduce((acc, s) => acc + s.volume, 0);
    const anusSemen = state.bodyFluids.anus.semen.reduce((acc, s) => acc + s.volume, 0);
    const mouthSemen = state.bodyFluids.mouth.semen.reduce((acc, s) => acc + s.volume, 0);

    if (bodySemen > 50) {
        semenDescParts.push("You are drenched in cum.");
    } else if (bodySemen > 20) {
        semenDescParts.push("You are covered in cum.");
    } else if (bodySemen > 0) {
        semenDescParts.push("You have some cum on you.");
    }

    if (vaginaSemen > 30) {
        semenDescParts.push("Your womb is bloated with semen.");
    } else if (vaginaSemen > 10) {
        semenDescParts.push("Semen is dripping from your vagina.");
    } else if (vaginaSemen > 0) {
        semenDescParts.push("You are wet with semen inside.");
    }

    if (anusSemen > 30) {
        semenDescParts.push("Your bowels are overflowing with semen.");
    } else if (anusSemen > 10) {
        semenDescParts.push("Semen is dripping from your anus.");
    } else if (anusSemen > 0) {
        semenDescParts.push("Your anus is filled with semen.");
    }

    if (mouthSemen > 15) {
        semenDescParts.push("You keep coughing up semen.");
    } else if (mouthSemen > 5) {
        semenDescParts.push("Your mouth is full of semen.");
    } else if (mouthSemen > 0) {
        semenDescParts.push("You have semen in your mouth.");
    }

    if (semenDescParts.length > 0) {
        finalDesc += ` <span style="color: #ff99ff;">${semenDescParts.join(' ')}</span>`;
    }
    }


    descEl.innerHTML = finalDesc;
}


function equipItem(itemId, subSlot) { // subSlot can be layer, hand, or null for 'back'
    const itemIndex = state.inventory.findIndex(i => i.id === itemId);
    if (itemIndex === -1) { console.error(`Item "${itemId}" not found.`); return; }

    const item = state.inventory[itemIndex];
    const targetSlotId = item.slot;
    const slot = state.equipment[targetSlotId];

    if (!slot) { console.error(`Slot "${targetSlotId}" not found.`); return; }

    // Determine what's currently equipped in the target location
    let currentlyEquippedItem = null;
    if (slot instanceof BackSlot) {
        currentlyEquippedItem = slot.item;
    } else if (slot instanceof HandHeldSlot && slot.hasOwnProperty(subSlot)) {
        currentlyEquippedItem = slot[subSlot];
    } else if (slot instanceof EquipmentSlot && slot.hasOwnProperty(subSlot)) {
        currentlyEquippedItem = slot[subSlot];
    }

    // If an item is there, move it to inventory
    if (currentlyEquippedItem) {
        state.inventory.push(currentlyEquippedItem);
    }

    // Equip the new item
    if (slot instanceof BackSlot) {
        slot.item = item;
    } else if (slot instanceof HandHeldSlot && slot.hasOwnProperty(subSlot)) {
        slot[subSlot] = item; // 'left' or 'right'
    } else if (slot instanceof EquipmentSlot && slot.hasOwnProperty(subSlot)) {
        slot[subSlot] = item; // 'skin', 'middle', 'outer'
    } else {
        console.error(`Cannot equip to invalid slot type for ${targetSlotId}`);
        if (currentlyEquippedItem) { state.inventory.pop(); } // Revert if equip fails
        return;
    }

    // Remove the newly equipped item from inventory
    state.inventory.splice(itemIndex, 1);
    // Sort inventory alphabetically for consistency, useful for UI
    state.inventory.sort((a, b) => a.name.localeCompare(b.name));
}

function unequipItem(slotId, subSlot) { // subSlot is layer, hand, or null
    const slot = state.equipment[slotId];
    if (!slot) { console.error(`Slot "${slotId}" not found.`); return; }

    let itemToUnequip = null;

    if (slot instanceof BackSlot) {
        itemToUnequip = slot.item;
        slot.item = null;
    } else if (slot instanceof HandHeldSlot && slot.hasOwnProperty(subSlot)) {
        itemToUnequip = slot[subSlot];
        slot[subSlot] = null;
    } else if (slot instanceof EquipmentSlot && slot.hasOwnProperty(subSlot)) {
        itemToUnequip = slot[subSlot];
        slot[subSlot] = null;
    }

    if (itemToUnequip) {
        state.inventory.push(itemToUnequip);
        // Sort inventory alphabetically for consistency
        state.inventory.sort((a, b) => a.name.localeCompare(b.name));
    } else {
        console.log(`Nothing to unequip from ${slotId} -> ${subSlot}`);
    }

    // Refresh UI
    buildEquipmentTab();
    updateCharDesc();
}

function getCoverageInfo() {
    const coverageMap = new Map(); // bodyPartId -> ClothingItem

    // Helper to process a slot by iterating from outer to inner layers
    const processSlot = (slot) => {
        const layers = ['outer', 'middle', 'skin'];
        for (const layer of layers) {
            const item = slot[layer];
            if (item && item.covers) {
                item.covers.forEach(partId => {
                    // Only set the coverage if it's not already set by a higher layer
                    if (!coverageMap.has(partId)) {
                        coverageMap.set(partId, item);
                    }
                });
            }
        }
    };

    // Iterate over all layered equipment slots
    ['head', 'neck', 'upper', 'lower', 'waist', 'arms', 'hands', 'legs', 'feet'].forEach(slotId => {
        const slot = state.equipment[slotId];
        if (slot instanceof EquipmentSlot) {
            processSlot(slot);
        }
    });

    // Non-layered slots can be added here if needed.

    return coverageMap;
}

/* ==============================================================
   REPRODUCTIVE SYSTEM
   ============================================================== */
function initMenstrualCycle() {
    // Randomize cycle and period length for variety
    state.menstrualCycle.cycleLength = Math.floor(Math.random() * 11) + 25; // 25-35 days
    state.menstrualCycle.periodLength = Math.floor(Math.random() * 4) + 4;   // 4-7 days
    state.menstrualCycle.currentDayInCycle = Math.floor(Math.random() * state.menstrualCycle.cycleLength) + 1;
}

function addSemen(location, volume, fatherId = 'unknown') {
    if (!state.bodyFluids[location]) {
        console.error(`Invalid semen location: ${location}`);
        return;
    }

    // For now, we'll just add it. Later we can consolidate entries from the same father.
    state.bodyFluids[location].semen.push({ fatherId, volume });

    // For backward compatibility with older save logic and simple checks
    if (location === 'vagina') {
        state.womb.semenVolume += volume;
    }
}

function isFertile() {
    if (state.parasite.canImpregnate) {
        return true; // Parasite makes host always receptive to its own eggs
    }
    const day = state.menstrualCycle.currentDayInCycle;
    // Simple fertility window model: Day 11 to 18
    return day >= 11 && day <= 18;
}

function calculateConception() {
    if (state.pregnancy.isPregnant) return; // Already pregnant

    // Human pregnancy logic (parasite logic is now in advanceDay)
    if (state.menstrualCycle.isFertile && state.womb.semenVolume > 0) {
        const conceptionChance = Math.min(1, state.womb.semenVolume / 10) * 0.33; // Max 33% chance
        if (Math.random() < conceptionChance) {
            state.pregnancy.isPregnant = true;
            state.pregnancy.type = 'human';
            state.pregnancy.days = 0;
            state.pregnancy.eggCount = 0;
            state.pregnancy.discoveryEventTriggered = false;
        }
    }

    // Semen is absorbed/cleared after one cycle, regardless of conception
    state.womb.semenVolume = 0;
}

function addParasiteEgg() {
    const now = state.currentTime.getTime();
    const hatchDelay = (8 + Math.random() * 2) * 60 * 60 * 1000; // 8-10 hours in ms
    const birthReadyDelay = (24 + Math.random() * 48) * 60 * 60 * 1000; // 1-3 days in ms

    const newEgg = {
        id: `egg_${now}_${Math.random()}`,
        laidAtTime: now,
        hatchAtTime: now + hatchDelay,
        birthReadyTime: now + hatchDelay + birthReadyDelay, // 1-3 days *after* hatching
        isDiscovered: false // This property may no longer be needed but is kept for safety.
    };

    state.parasite.eggs.push(newEgg);
}

function layParasiteEggs() {
    if (!state.parasite.canImpregnate) return;

    // 1. Lay the first egg (100% chance)
    addParasiteEgg();

    // 2. Loop for additional eggs with halving probability
    let chance = 0.5;
    while (Math.random() < chance) {
        addParasiteEgg();
        chance /= 2;
    }
}

function advanceDay() {
    // This function is called for each day that passes.
    if (state.parasite.canImpregnate) {
        // Disable menstrual cycle and lay eggs
        state.menstrualCycle.isFertile = true;
        layParasiteEggs();
    } else {
        state.menstrualCycle.currentDayInCycle++;
        if (state.menstrualCycle.currentDayInCycle > state.menstrualCycle.cycleLength) {
            state.menstrualCycle.currentDayInCycle = 1;
        }
        state.menstrualCycle.isFertile = isFertile();
    }

    if (state.pregnancy.isPregnant) {
        // PARASITE TAKEOVER LOGIC
        if (state.pregnancy.type === 'human' && state.parasite.canImpregnate && !state.storyEventActive) {
            // Add a chance for parasite to overwrite a human pregnancy (15% chance per day)
            if (Math.random() < 0.15) {
                // Abort human pregnancy
                state.pregnancy.isPregnant = false;
                state.pregnancy.type = null;
                state.pregnancy.days = 0;
                state.pregnancy.discoveryEventTriggered = false;

                // Trigger the story event
                state.storyEventActive = true;
                state.locationBeforeEvent = state.currentLocation;
                goToScene('parasite_takeover_event', 0);
                // The new egg laying logic will run in advanceDay on subsequent days
                return; // Stop processing for this day
            }
        }

        // PREGNANCY DISCOVERY EVENT
        if (!state.pregnancy.discoveryEventTriggered && state.pregnancy.days >= 14 && !state.storyEventActive) {
            state.pregnancy.discoveryEventTriggered = true; // Set flag so it only happens once
            state.storyEventActive = true;
            state.locationBeforeEvent = state.currentLocation;

            if (state.pregnancy.type === 'human') {
                goToScene('human_pregnancy_discovery', 0);
            }
            return; // Stop processing for this day
        }

        state.pregnancy.days++;
        // Add a cumulative fatigue effect during pregnancy
        state.needs.tiredness = Math.max(0, state.needs.tiredness - 150);

        // Check for birth event trigger
        if (state.pregnancy.type === 'human' && state.pregnancy.days > 40 && !state.storyEventActive) {
            const chance = (state.pregnancy.days - 40) * 0.1; // 10% chance per day after day 40
            if (Math.random() < chance) {
                state.storyEventActive = true;
                state.locationBeforeEvent = state.currentLocation;
                goToScene('human_water_breaking_event', 0);
                return; // Stop further processing for this day as an event is triggered
            }
        }
    }

    // Check for recurring reminders
    const today = state.currentTime;
    const currentMonth = today.getMonth() + 1; // getMonth() is 0-indexed
    const currentDay = today.getDate();

    if (state.journal.recurringReminders) {
        state.journal.recurringReminders.forEach(reminder => {
            if (reminder.month === currentMonth && reminder.day === currentDay) {
                // To prevent duplicates, create a unique reminder text for the current year
                const reminderTextForYear = `${reminder.text} (${today.getFullYear()})`;
                const alreadyExists = state.journal.reminders.some(r => r.text === reminderTextForYear);

                if (!alreadyExists) {
                    state.journal.reminders.push({
                        date: today.toISOString().split('T')[0], // 'YYYY-MM-DD'
                        text: reminderTextForYear
                    });
                }
            }
        });
    }

    calculateConception();
}

function completeHumanBirth() {
    // Reset pregnancy state
    state.pregnancy.isPregnant = false;
    state.pregnancy.type = null;
    state.pregnancy.days = 0;
    state.pregnancy.eggCount = 0;
    state.pregnancy.discoveryEventTriggered = false;

    // End the event and return to the previous location after 1 hour
    state.storyEventActive = false;
    goToScene(state.locationBeforeEvent, 3600);
}

function endTakeoverEvent() {
    state.storyEventActive = false;
    goToScene(state.locationBeforeEvent, 3600); // 1 hour penalty for the ordeal
}

function endDiscoveryEvent() {
    state.storyEventActive = false;
    // No time penalty for just a realization.
    goToScene(state.locationBeforeEvent, 0);
}

function handleEggHatching() {
    const now = state.currentTime.getTime();
    const eggsToHatch = state.parasite.eggs.filter(egg => now >= egg.hatchAtTime);
    const numHatched = eggsToHatch.length;

    if (numHatched === 0) {
        // This case should ideally not be reached if called correctly, but it's a safeguard.
        state.storyEventActive = false;
        goToScene(state.locationBeforeEvent, 0);
        return;
    }

    // Create new worms from the eggs that are hatching
    eggsToHatch.forEach(egg => {
        const newWorm = {
            id: `worm_${egg.id}`,
            birthReadyTime: egg.birthReadyTime,
        };
        state.parasite.worms.push(newWorm);
    });

    // Remove the eggs that have hatched
    state.parasite.eggs = state.parasite.eggs.filter(egg => now < egg.hatchAtTime);

    // Apply stat penalties for each egg that hatched
    state.needs.stress = Math.min(state.ranges.stress, state.needs.stress + (50 * numHatched));
    state.needs.trauma = Math.min(state.ranges.trauma, state.needs.trauma + (25 * numHatched));
    state.needs.happiness = Math.max(0, state.needs.happiness - (40 * numHatched));
    state.needs.tiredness = Math.max(0, state.needs.tiredness - (1000 * numHatched));

    state.storyEventActive = false;
    forceGlobalUIRefresh(); // Update UI immediately to reflect changes
    goToScene(state.locationBeforeEvent, 3600); // 1-hour time penalty for the ordeal
}

function deliverWorms() {
    const now = state.currentTime.getTime();
    const wormsToDeliver = state.parasite.worms.filter(worm => now >= worm.birthReadyTime);
    const numToDeliver = wormsToDeliver.length;

    if (numToDeliver === 0) {
        // This should not be possible if the link is hidden, but it's a safeguard.
        return;
    }

    let totalTimeInSeconds = 0;
    for (let i = 0; i < numToDeliver; i++) {
        totalTimeInSeconds += (10 + Math.random() * 10) * 60; // 10-20 minutes in seconds
    }

    // Block the player and advance time
    state.storyEventActive = true;
    advanceTime(totalTimeInSeconds);

    // Remove the delivered worms from the state
    state.parasite.worms = state.parasite.worms.filter(worm => now < worm.birthReadyTime);

    // Update the result scene's description and go to it
    state.scenes.birth_results.description = `After a grueling and bizarre ordeal, you have delivered ${numToDeliver} alien worms into the nest. You feel a sense of relief, but also a deep violation. The nest pulses gently, seeming to nurture its new inhabitants.`;
    goToScene('birth_results', 0);
}

function finishBirthing() {
    state.storyEventActive = false;
    goToScene('private_room', 0);
}

/* ==============================================================
   SEX SCENE LOGIC
   ============================================================== */
function startSexScene(participantIds) {
    // Store initial clothing state to restore later
    state.sexScene.initialPlayerClothing = JSON.parse(JSON.stringify(state.equipment));

    state.sexScene.isActive = true;
    state.sexScene.actors = participantIds.map(id => {
        const actor = {
            id: id,
            hasClimaxed: false,
            lastAction: null,
            // NOTE: This clothing tracking is simplified. A real implementation would need to
            // differentiate between player and NPC clothing. For now, we assume all undress
            // actions target the player.
            clothing: Object.values(state.equipment)
                           .flatMap(slot => Object.values(slot))
                           .filter(item => item !== null && typeof item === 'object')
        };
        if (id !== 'player') {
            actor.arousal = 0;
            actor.maxArousal = 100; // Can be customized later
        }
        return actor;
    });

    state.sexScene.turn = participantIds[0]; // Player always starts
    state.sexScene.currentState = 'main';
    state.sexScene.log = ['The scene begins. You are both fully clothed.'];
    
    state.storyEventActive = true;
    
    renderSexScene();
}

function processSexAction(actorId, actionBundle, targetId) {
    if (!state.sexScene.isActive || state.sexScene.turn !== actorId) {
        return; // Not your turn
    }

    const giver = state.sexScene.actors.find(a => a.id === actorId);
    const receiver = state.sexScene.actors.find(a => a.id === targetId);

    actionBundle.forEach(action => {
        // State machine check
        const requiredState = action.requiredState;
        const currentState = state.sexScene.currentState;
        if ((Array.isArray(requiredState) && !requiredState.includes(currentState)) || 
            (!Array.isArray(requiredState) && requiredState !== currentState)) {
            state.sexScene.log.push(`<i>You can't do that right now (${action.name}).</i>`);
            return; // 'continue' in a forEach loop
        }

        // Hard block for physical actions on clothed parts
        if (action.requires_no_clothing_on_target && isBodyPartBlocked(action.requires_no_clothing_on_target)) {
            state.sexScene.log.push(`<i>${actorId} tries to ${action.name}, but clothing is in the way.</i>`);
            return;
        }
        
        // Hard block for insertion actions (double check)
        if (action.tags.includes('insertion') && action.target && isBodyPartBlocked(action.target)) {
            state.sexScene.log.push(`<i>${actorId} tries to ${action.name}, but clothing is in the way.</i>`);
            return;
        }

        // Undress logic
        if (action.tags.includes('undress')) {
            let itemsRemoved = [];
            if (action.tags.includes('top')) {
                // Remove ONE layer of clothing from top, from outer to inner
                if (state.equipment.upper.outer) {
                    itemsRemoved.push(state.equipment.upper.outer.name);
                    unequipItem('upper', 'outer');
                } else if (state.equipment.upper.middle) {
                    itemsRemoved.push(state.equipment.upper.middle.name);
                    unequipItem('upper', 'middle');
                } else if (state.equipment.upper.skin) {
                    itemsRemoved.push(state.equipment.upper.skin.name);
                    unequipItem('upper', 'skin');
                }
            } else if (action.tags.includes('bottom')) {
                // Remove ONE layer of clothing from bottom, from outer to inner
                if (state.equipment.lower.outer) {
                    itemsRemoved.push(state.equipment.lower.outer.name);
                    unequipItem('lower', 'outer');
                } else if (state.equipment.lower.middle) {
                    itemsRemoved.push(state.equipment.lower.middle.name);
                    unequipItem('lower', 'middle');
                } else if (state.equipment.lower.skin) {
                    itemsRemoved.push(state.equipment.lower.skin.name);
                    unequipItem('lower', 'skin');
                }
            }

            if (itemsRemoved.length > 0) {
                if (actorId === 'player') {
                    state.sexScene.log.push(`<b>You remove your ${itemsRemoved.join(', ')}.</b>`);
                } else {
                    state.sexScene.log.push(`<b>${actorId} removes your ${itemsRemoved.join(', ')}.</b>`);
                }
            } else {
                state.sexScene.log.push(`<i>${actorId} tries to remove clothing, but there's nothing there.</i>`);
            }
        }

        // Arousal logic
        if (giver.id === 'player') {
            state.needs.arousal = Math.min(state.ranges.arousal, state.needs.arousal + action.arousalGiver);
        } else {
            giver.arousal = Math.min(giver.maxArousal, giver.arousal + action.arousalGiver);
        }
        if (receiver.id === 'player') {
            state.needs.arousal = Math.min(state.ranges.arousal, state.needs.arousal + action.arousalReceiver);
        } else {
            receiver.arousal = Math.min(receiver.maxArousal, receiver.arousal + action.arousalReceiver);
        }
        
        // Log generation
        let logMessage = action.description || `${actorId} uses ${action.name} on ${targetId}.`;
        logMessage = logMessage.replace(/{actor}/g, `<b>${actorId}</b>`).replace(/{target}/g, `<b>${targetId}</b>`);
        state.sexScene.log.push(logMessage);
        giver.lastAction = action.name;

        // Stat tracking
        if (actorId === 'player') {
            if (action.tags.includes('vaginal') && action.tags.includes('penetration')) state.stats.vaginalSexCount++;
            if (action.tags.includes('anal') && action.tags.includes('penetration')) state.stats.analSexCount++;
            if (action.tags.includes('oral')) state.stats.oralSexGivenCount++;
        } else {
            if (action.tags.includes('oral')) state.stats.oralSexReceivedCount++;
        }

        // State transition
        if (action.nextState) {
            state.sexScene.currentState = action.nextState;
            state.sexScene.log.push(`<b>The scene is now in state: ${action.nextState}</b>`);
        }

        checkForClimax(giver.id, action);
        checkForClimax(receiver.id, action);
    });

    // Advance turn (happens after all actions in bundle are processed)
    const currentIndex = state.sexScene.actors.findIndex(a => a.id === actorId);
    const nextIndex = (currentIndex + 1) % state.sexScene.actors.length;
    state.sexScene.turn = state.sexScene.actors[nextIndex].id;
}

function checkForClimax(actorId, action) {
    const actor = state.sexScene.actors.find(a => a.id === actorId);
    if (!actor || actor.hasClimaxed) return;

    let currentArousal, maxArousal;
    if (actorId === 'player') {
        currentArousal = state.needs.arousal;
        maxArousal = state.ranges.arousal;
    } else {
        currentArousal = actor.arousal;
        maxArousal = actor.maxArousal;
    }

    if (currentArousal >= maxArousal) {
        actor.hasClimaxed = true;
        state.sexScene.log.push(`<b>${actor.id} has climaxed!</b>`);
        
        if (actor.id === 'player') {
            state.stats.timesClimaxed++;
            state.needs.arousal = 0; // Reset player's global arousal
            state.stats.totalGirlCumExpelled += 10; // Arbitrary value for now
        } else {
            // This is an NPC climax
            const npc = state.npcs[actor.id];
            if (npc) {
                let semenLocation = 'body'; // Default

                // Check for penetration states first
                if (state.sexScene.currentState === 'vaginal_sex') {
                    semenLocation = 'vagina';
                    state.stats.vaginalCreampiesReceived++;
                } else if (state.sexScene.currentState === 'anal_sex') {
                    semenLocation = 'anus';
                    state.stats.analCreampiesReceived++;
                } else {
                    // If not in a penetration state, the location is based on context.
                    // Default to 'body' unless a more specific target can be determined.
                    const climaxingActor = state.sexScene.actors.find(a => a.id === actorId);
                    const lastActionName = climaxingActor.lastAction;

                    if (lastActionName) {
                        let lastAction = null;
                        // Find the action object from its name
                        for (const part in sexActions.universal) {
                            const foundAction = sexActions.universal[part].find(a => a.name === lastActionName);
                            if (foundAction) {
                                lastAction = foundAction;
                                break;
                            }
                        }

                        // If the NPC's last action was oral on the vagina, target the vagina.
                        if (lastAction && lastAction.tags.includes('oral') && lastAction.tags.includes('vaginal')) {
                            semenLocation = 'vagina';
                        }
                    }
                }
                
                addSemen(semenLocation, npc.cumProduction, npc.semenId);
            }
            actor.arousal = 0; // Reset NPC's temporary arousal
        }
    }
}

function rehydrateEquipment(equipmentData) {
    const hydratedEquipment = {};
    for (const slotId in equipmentData) {
        const loadedSlot = equipmentData[slotId];
        if (!loadedSlot) continue;

        if (loadedSlot.hasOwnProperty('skin')) { // EquipmentSlot
            const newSlot = new EquipmentSlot(loadedSlot.id, loadedSlot.name);
            ['skin', 'middle', 'outer'].forEach(layer => {
                if (loadedSlot[layer]) {
                    newSlot[layer] = new ClothingItem(loadedSlot[layer]);
                }
            });
            hydratedEquipment[slotId] = newSlot;
        } else if (loadedSlot.hasOwnProperty('left')) { // HandHeldSlot
            const newSlot = new HandHeldSlot(loadedSlot.name);
            if (loadedSlot.left) newSlot.left = new ClothingItem(loadedSlot.left);
            if (loadedSlot.right) newSlot.right = new ClothingItem(loadedSlot.right);
            hydratedEquipment[slotId] = newSlot;
        } else if (loadedSlot.hasOwnProperty('item')) { // BackSlot
            const newSlot = new BackSlot(loadedSlot.name);
            if (loadedSlot.item) newSlot.item = new ClothingItem(loadedSlot.item);
            hydratedEquipment[slotId] = newSlot;
        }
    }
    return hydratedEquipment;
}

function endSexScene() {
    // Restore player's clothing and UI
    if (state.sexScene.initialPlayerClothing) {
        state.equipment = rehydrateEquipment(state.sexScene.initialPlayerClothing);
        updateCharDesc(); // Update the sidebar description
    }
    
    // Reset the scene state
    state.sexScene.isActive = false;
    state.sexScene.actors = [];
    state.sexScene.turn = '';
    state.sexScene.log = [];
    state.sexScene.currentState = 'foreplay';
    // We keep initialPlayerClothing until after the cleanup scene
    
    state.storyEventActive = false;
    
    // Go to the cleanup scene
    goToScene('sex_cleanup', 0);
}

function returnFromSexScene() {
    // Now we can clear the initial clothing backup
    state.sexScene.initialPlayerClothing = null;
    // Go back to the previous location after a short time penalty
    goToScene(state.locationBeforeEvent || 'foyer', 600);
}

function isBodyPartCovered(partId) {
    const coverageMap = getCoverageInfo();
    if (!coverageMap.has(partId)) {
        return false;
    }
    const coveringItem = coverageMap.get(partId);
    // Transparent items don't count as "covering" for visibility.
    if (coveringItem.tags.includes('transparent')) {
        return false;
    }
    return true;
}

function isBodyPartBlocked(partId) {
    const coverageMap = getCoverageInfo();
    if (!coverageMap.has(partId)) {
        return false; // Not covered, so not blocked
    }
    const coveringItem = coverageMap.get(partId);
    if (coveringItem.tags.includes('fetish-wear')) {
        return false; // Fetish-wear never blocks
    }
    // Any other item, including transparent, blocks.
    return true;
}

function getArousalLabel(arousal, maxArousal) {
    const percentage = (arousal / maxArousal) * 100;
    if (percentage < 10) return { text: "Unstimulated", color: "#add8e6" }; // Light Blue
    if (percentage < 30) return { text: "Slightly Aroused", color: "#87ceeb" }; // Sky Blue
    if (percentage < 50) return { text: "Aroused", color: "#ffc0cb" }; // Pink
    if (percentage < 70) return { text: "Visibly Excited", color: "#ffb6c1" }; // Light Pink
    if (percentage < 90) return { text: "Highly Aroused", color: "#ff69b4" }; // Hot Pink
    return { text: "Ready to Burst", color: "#ff1493" }; // Deep Pink
}

function renderSexScene() {
    if (!state.sexScene.isActive) {
        goToScene(state.locationBeforeEvent || 'foyer', 0);
        return;
    }

    const c = document.getElementById('mainArea');
    c.innerHTML = ''; // Clear the area first

    const mainContainer = document.createElement('div');
    mainContainer.style.margin = 'auto';
    mainContainer.style.maxWidth = '900px';
    mainContainer.style.textAlign = 'center';

    mainContainer.innerHTML += '<h2 class="eventTitle">Sex Scene</h2>';
    const lastLog = state.sexScene.log[state.sexScene.log.length - 1];
    mainContainer.innerHTML += `<p><em>${lastLog || 'The scene begins...'}</em></p>`;

    const columnsContainer = document.createElement('div');
    columnsContainer.style.display = 'flex';
    columnsContainer.style.textAlign = 'left';
    columnsContainer.style.marginTop = '1.5rem';

    const leftColumn = document.createElement('div');
    leftColumn.style.flex = '1';
    leftColumn.style.paddingRight = '1.5rem';
    
    const npc = state.sexScene.actors.find(a => a.id !== 'player');
    if (npc) {
        const arousal = getArousalLabel(npc.arousal, npc.maxArousal);
        leftColumn.innerHTML = `<h4>${npc.id}'s State</h4><span style="color: ${arousal.color}; font-weight: bold;">${arousal.text}</span>`;
        if (npc.lastAction) {
            leftColumn.innerHTML += `<br><small>Last Action: ${npc.lastAction}</small>`;
        }
    }
    columnsContainer.appendChild(leftColumn);

    const rightColumn = document.createElement('div');
    rightColumn.style.flex = '3';

    if (state.sexScene.turn === 'player') {
        const player = state.sexScene.actors.find(a => a.id === 'player');
        if (player && player.lastAction) {
            rightColumn.innerHTML += `<p style="margin-bottom: 0.5rem; font-style: italic;"><small>Your last action was: ${player.lastAction}</small></p>`;
        }
        rightColumn.innerHTML += '<h4>Your Action</h4>';
        const actionContainer = document.createElement('div');
        actionContainer.style.display = 'flex';
        actionContainer.style.gap = '1rem';

        // Helper function to generate action groups
        const createActionColumn = (title, actionScope, parts) => {
            const column = document.createElement('div');
            column.style.flex = '1';
            
            let html = `<h5>${title}</h5>`;
            
            parts.forEach(partName => {
                const actions = sexActions[actionScope][partName] ? sexActions[actionScope][partName].filter(a => {
                    const required = a.requiredState;
                    const current = state.sexScene.currentState;
                    const passesStateCheck = Array.isArray(required) ? required.includes(current) : required === current;
                    
                    // Exclude NPC-only tags for player rendering
                    const isNpcOnly = a.tags && a.tags.includes('npc-only');
                    if (isNpcOnly) return false;

                    // Hide undress actions if nothing is left to remove
                    if (a.tags && a.tags.includes('undress')) {
                        if (a.tags.includes('top')) {
                            if (!state.equipment.upper.outer && !state.equipment.upper.middle && !state.equipment.upper.skin) {
                                return false;
                            }
                        }
                        if (a.tags.includes('bottom')) {
                            if (!state.equipment.lower.outer && !state.equipment.lower.middle && !state.equipment.lower.skin) {
                                return false;
                            }
                        }
                    }
                    
                    return passesStateCheck;
                }) : [];

                if (actions.length > 0) {
                    html += `<div style="margin-bottom: 0.8rem;"><strong>${partName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase())}:</strong>`;
                    actions.forEach((action, index) => {
                        let canPerform = true;
                        if (action.requires_clothing && !((state.equipment.lower.skin && state.equipment.lower.skin.tags.includes(action.requires_clothing)) || (state.equipment.upper.skin && state.equipment.upper.skin.tags.includes(action.requires_clothing)))) {
                            canPerform = false;
                        }
                        if (action.requires_no_clothing_on_target && isBodyPartCovered(action.requires_no_clothing_on_target)) {
                            canPerform = false;
                        }

                        if (canPerform) {
                            // Correctly construct the ID and value with the scope
                            const radioId = `action-${actionScope}-${partName}-${index}`;
                            html += `<br><label for="${radioId}"><input type="radio" id="${radioId}" name="sex-action-${partName}" value="${actionScope}|${partName}|${index}"> ${action.name}</label>`;
                        }
                    });
                    html += `</div>`;
                }
            });

            column.innerHTML = html;
            return column;
        };

        const universalParts = ['left_hand', 'right_hand', 'mouth', 'breasts', 'legs'];
        const playerParts = ['mouth', 'vagina', 'anus']; // Player-specific actions

        const universalColumn = createActionColumn('Universal Actions', 'universal', universalParts);
        const playerColumn = createActionColumn('Personal Actions', 'player', playerParts);

        actionContainer.appendChild(universalColumn);
        actionContainer.appendChild(playerColumn);
        
        rightColumn.appendChild(actionContainer);
        rightColumn.innerHTML += '<button id="submit-sex-action" class="overlayBtn" style="margin-top: 1rem;">Perform Action</button>';
    }
    columnsContainer.appendChild(rightColumn);
    mainContainer.appendChild(columnsContainer);

    const endBtn = document.createElement('button');
    endBtn.id = 'end-sex-scene';
    endBtn.className = 'overlayBtn';
    endBtn.style.marginTop = '1.5rem';
    endBtn.textContent = 'End Scene';
    mainContainer.appendChild(endBtn);
    
    c.appendChild(mainContainer);

    if (state.sexScene.turn === 'player') {
        document.getElementById('submit-sex-action').onclick = handlePlayerAction;
    }
    document.getElementById('end-sex-scene').onclick = endSexScene;
}

function handlePlayerAction() {
    const selectedRadios = document.querySelectorAll('input[type="radio"][name^="sex-action-"]:checked');
    if (selectedRadios.length === 0) {
        alert("Please select at least one action.");
        return;
    }

    const actionBundle = [];
    selectedRadios.forEach(radio => {
        const [scope, bodyPart, actionIndex] = radio.value.split('|');
        // Fetch action from the correct scope (universal or player)
        const action = sexActions[scope][bodyPart][actionIndex];
        actionBundle.push(action);
    });
    
    const targetId = state.sexScene.actors.find(a => a.id !== 'player').id;
    
    processSexAction('player', actionBundle, targetId);
    
    renderSexScene();
    updateNeedsUI();
    
    if (state.sexScene.isActive && state.sexScene.turn !== 'player') {
        handleNpcTurn();
    }
}

function handleNpcTurn() {
    if (!state.sexScene.isActive) return;

    const npcId = state.sexScene.turn;
    const currentState = state.sexScene.currentState;
    const actionBundle = [];

    const player = state.sexScene.actors.find(a => a.id === 'player');
    const playerLastActionName = player ? player.lastAction : null;
    let playerLastActionTags = [];
    if (playerLastActionName) {
        for (const part in sexActions.universal) {
            const action = sexActions.universal[part].find(a => a.name === playerLastActionName);
            if (action) {
                playerLastActionTags = action.tags;
                break;
            }
        }
    }

    // For each body part, find valid actions and randomly choose one
    for (const bodyPart in sexActions.universal) {
        const validActions = sexActions.universal[bodyPart].filter(action => {
            const required = action.requiredState;
            const passesStateCheck = Array.isArray(required) ? required.includes(currentState) : required === currentState;
            return passesStateCheck && !action.tags.includes('player-only');
        });

        if (validActions.length > 0) {
            if (Math.random() < 0.5) { // 50% chance to act with this body part
                let chosenAction;
                // If player had a last action, try to reciprocate
                if (playerLastActionTags.length > 0) {
                    const reciprocatingActions = validActions.filter(action => 
                        action.tags.some(tag => playerLastActionTags.includes(tag))
                    );
                    
                    // 75% chance to pick a reciprocating action if available
                    if (reciprocatingActions.length > 0 && Math.random() < 0.75) {
                        chosenAction = reciprocatingActions[Math.floor(Math.random() * reciprocatingActions.length)];
                    } else {
                        chosenAction = validActions[Math.floor(Math.random() * validActions.length)];
                    }
                } else {
                    // Default random selection
                    chosenAction = validActions[Math.floor(Math.random() * validActions.length)];
                }
                actionBundle.push(chosenAction);
            }
        }
    }

    // If no actions were chosen, just skip the turn for now.
    if (actionBundle.length === 0) {
        state.sexScene.log.push(`<i>${npcId} considers their next move...</i>`);
        const currentIndex = state.sexScene.actors.findIndex(a => a.id === npcId);
        const nextIndex = (currentIndex + 1) % state.sexScene.actors.length;
        state.sexScene.turn = state.sexScene.actors[nextIndex].id;
        renderSexScene();
        return;
    }

    processSexAction(npcId, actionBundle, 'player');
    
    renderSexScene();
    updateNeedsUI();
}

/* ==============================================================
   UTILS
   ============================================================== */

function getLuminance(hex) {
    hex = hex.replace("#", "");
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    // Perceived brightness formula
    return (r * 299 + g * 587 + b * 114) / 1000;
}

function fmtHM(d){ return d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit',hour12:false}); }
function fmtDate(d) {
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const day = String(d.getDate()).padStart(2, '0');
    const month = months[d.getMonth()];
    const year = d.getFullYear();
    return `${day} ${month} ${year}`;
}

function formatMoney(amount) {
    if (amount >= 10000000) {
        return `$${(amount / 1000000).toFixed(0)}M`;
    } else if (amount >= 10000) {
        return `$${(amount / 1000).toFixed(0)}k`;
    } else if (amount >= 1000) {
        return `$${amount.toFixed(0)}`;
    } else {
        return `$${amount.toFixed(2)}`;
    }
}

function getDaysBetween(date1, date2) {
    const oneDay = 24 * 60 * 60 * 1000;
    // Discard time and timezone info for consistent day difference calculation
    const d1 = Date.UTC(date1.getFullYear(), date1.getMonth(), date1.getDate());
    const d2 = Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate());
    return Math.floor((d1 - d2) / oneDay);
}

function applySettings() {
  const settings = state.settings;
  document.body.style.fontFamily = settings.fontFamily;
  document.body.style.fontSize = settings.fontSize;
}

function changeFont(font) {
  state.settings.fontFamily = font;
  applySettings();
}

function changeFontSize(size) {
  state.settings.fontSize = size;
  applySettings();
}

function forceGlobalUIRefresh() {
  updateHeader();
  updateNeedsUI();
}

function checkStatTriggers() {
  if (state.storyEventActive) {
    return; // Don't interrupt story events
  }

  // Check for Stress max-out
  if (state.needs.stress >= state.ranges.stress) {
    state.storyEventActive = true;
    state.locationBeforeEvent = state.currentLocation;
    goToScene('stress_collapse_event', 0);
  }

  // Check for Arousal max-out
  if (state.needs.arousal >= state.ranges.arousal) {
    state.storyEventActive = true;
    state.locationBeforeEvent = state.currentLocation;
    goToScene('arousal_max_event', 0);
  }
}

/* Advance time by a given number of seconds and refresh the header */
function checkEventCondition(condition) {
    if (!condition) return true; // No condition means it can always trigger

    switch (condition.type) {
        case 'human_pregnancy_early':
            return state.pregnancy.isPregnant &&
                   state.pregnancy.type === 'human' &&
                   state.pregnancy.days >= 7 &&
                   state.pregnancy.days <= 35;
        case 'parasite_pregnancy':
            return state.parasite.eggs.length > 0;
        case 'has_piercings':
            const hasEquipped = Object.values(state.playerBody).some(p => p.piercings && p.piercings.length > 0);
            const hasStored = state.unequippedPiercings.length > 0;
            return hasEquipped || hasStored;
        // Future condition types can be added here
        default:
            return false;
    }
}

function advanceTime(seconds, updateUI = true) {
  if (typeof seconds !== 'number' || seconds < 0) return;

  const initialDay = Math.floor(state.currentTime.getTime() / (1000 * 60 * 60 * 24));

  const needs = state.needs;
  const ranges = state.ranges;

  // --- CALCULATE DECREASES ---

  // Fatigue (tiredness) decreases over time. 10000 points over 24 hours (86400s)
  const fatigueDecrease = seconds * (10000 / 86400);
  needs.tiredness = Math.max(0, needs.tiredness - fatigueDecrease);

  // Stress recovers over time: 1 point every 30 seconds
  const stressDecrease = seconds * (1 / 30);
  needs.stress = Math.max(0, needs.stress - stressDecrease);

  // Trauma recovers very slowly: 1 point every hour (3600s)
  const traumaDecrease = seconds * (1 / 3600);
  needs.trauma = Math.max(0, needs.trauma - traumaDecrease);

  // Alcohol metabolizes: 12 points every hour (3600s)
  const alcoholDecrease = seconds * (12 / 3600);
  needs.alcohol = Math.max(0, needs.alcohol - alcoholDecrease);

  // Drugs wear off: 6 points every hour (3600s)
  const drugsDecrease = seconds * (6 / 3600);
  needs.drugs = Math.max(0, needs.drugs - drugsDecrease);

  // Arousal has two-tier decay
  const arousal50PctMark = ranges.arousal / 2;
  if (needs.arousal >= arousal50PctMark) {
    // Rate for >=50%: 500 points over 10 mins (600s)
    const arousalDecrease = seconds * (500 / 600);
    needs.arousal = Math.max(arousal50PctMark, needs.arousal - arousalDecrease);
  } else {
    // Rate for <50%: 500 points over 5 mins (300s)
    const arousalDecrease = seconds * (500 / 300);
    needs.arousal = Math.max(0, needs.arousal - arousalDecrease);
  }

  state.currentTime = new Date(state.currentTime.getTime() + (seconds * 1000));

  const finalDay = Math.floor(state.currentTime.getTime() / (1000 * 60 * 60 * 24));
  const daysPassed = finalDay - initialDay;

  if (daysPassed > 0) {
    for (let i = 0; i < daysPassed; i++) {
      advanceDay();
    }
  }

  if (updateUI) {
    forceGlobalUIRefresh();
  }

  // New Hatching Logic
  if (!state.storyEventActive && state.parasite.eggs.some(egg => state.currentTime.getTime() >= egg.hatchAtTime)) {
      state.storyEventActive = true;
      state.locationBeforeEvent = state.currentLocation;
      renderScene('parasite_hatch_event');
      return; // Exit advanceTime to prevent other triggers
  }

  checkStatTriggers();
}

/* ==============================================================
   JOURNAL
   ============================================================== */
function buildJournalOverlay() {
    const body = document.querySelector('#btnJournal-overlay .overlayBody');
    if (!body) return;

    // --- Active Quests (now filters hidden quests) ---
    let activeQuestsHtml = '<ul>';
    const activeQuests = state.journal.quests.filter(q => !q.complete && !q.hidden);
    if (activeQuests.length > 0) {
        activeQuests.forEach(q => {
            activeQuestsHtml += `<li><strong>${q.title}:</strong> ${q.description}</li>`;
        });
    } else {
        activeQuestsHtml += '<li>No active quests.</li>';
    }
    activeQuestsHtml += '</ul>';

    // --- Completed Quests (now collapsible with count) ---
    const completedQuests = state.journal.quests.filter(q => q.complete);
    const completedCount = completedQuests.length;
    const completedQuestsHeaderHtml = `<h4 id="completed-quests-header" style="cursor: pointer;">Completed Quests (${completedCount})</h4>`;

    let completedQuestsListHtml = '<ul style="display: none;">'; // Start hidden
    if (completedCount > 0) {
        completedQuests.forEach(q => {
            completedQuestsListHtml += `<li><s><strong>${q.title}:</strong> ${q.description}</s></li>`;
        });
    } else {
        completedQuestsListHtml += '<li>No completed quests yet.</li>';
    }
    completedQuestsListHtml += '</ul>';

    // --- Reminders ---
    let remindersHtml = '<ul>';
    if (state.journal.reminders.length > 0) {
        state.journal.reminders.forEach(r => {
            if (typeof r === 'string') {
                remindersHtml += `<li>${r}</li>`;
            } else if (r && r.text && r.date) {
                const reminderDate = new Date(r.date + 'T00:00:00');
                remindersHtml += `<li>${r.text} (on ${reminderDate.toLocaleDateString()})</li>`;
            }
        });
    } else {
        remindersHtml += '<li>No reminders.</li>';
    }
    remindersHtml += '</ul>';

    body.innerHTML = `
        <div id="journal-content-wrapper">
            <div>
                <h4>Active Quests</h4>
                ${activeQuestsHtml}
            </div>
            <div style="margin-top: 1rem;">
                ${completedQuestsHeaderHtml}
                <div id="completed-quests-list-container">
                    ${completedQuestsListHtml}
                </div>
            </div>
            <div style="margin-top: 1rem;">
                <h4>Reminders</h4>
                ${remindersHtml}
            </div>
            <div style="margin-top: 1rem; display: flex; flex-direction: column; flex-grow: 1;">
                <h4>Notes</h4>
                <textarea id="journal-notepad" style="width: 98%; background: #111; color: #eee; border: 0.0625rem solid #444; flex-grow: 1;"></textarea>
            </div>
        </div>
    `;

    // Add click listener for collapsible section
    const completedHeader = document.getElementById('completed-quests-header');
    if (completedHeader) {
        completedHeader.onclick = () => {
            const list = document.querySelector('#completed-quests-list-container ul');
            if (list) {
                const isHidden = list.style.display === 'none';
                list.style.display = isHidden ? 'block' : 'none';
            }
        };
    }

    const notepad = document.getElementById('journal-notepad');
    notepad.value = state.journal.notes;
    notepad.addEventListener('input', (event) => {
        state.journal.notes = event.target.value;
    });
}

/* ==============================================================
   SAVES
   ============================================================== */
function isSaveDataValid(saveData) {
    if (!saveData || typeof saveData !== 'object') return false;
    if (!saveData.state || typeof saveData.state !== 'object') return false;

    const s = saveData.state;
    const requiredKeys = ['currentTime', 'money', 'needs', 'skills', 'npcs', 'journal', 'currentLocation', 'scenes'];
    for (const key of requiredKeys) {
        if (!(key in s)) {
            console.error(`Save data validation failed: Missing key "${key}"`);
            return false;
        }
    }
    return true;
}

function buildLoadScreen() {
    const body = document.querySelector('#loadBtn-overlay .overlayBody');
    if (!body) return;

    let slotsHtml = '';
    for (let i = 1; i <= 10; i++) {
        const saveKey = `infestation_save_${i}`;
        const savedData = localStorage.getItem(saveKey);
        let slotName = "Empty Slot";
        let slotDate = "";

        if (savedData) {
            const data = JSON.parse(savedData);
            slotName = data.name;
            slotDate = new Date(data.date).toLocaleString();
        }

        slotsHtml += `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; border-bottom: 0.0625rem solid #444;">
                <div style="flex-grow: 1;">
                    <span style="font-weight: bold;">${i}: ${slotName}</span>
                    <span style="font-size: 0.8em; color: #aaa; margin-left: 1rem;">${slotDate}</span>
                </div>
                <div>
                    <button class="overlayBtn" disabled>Save</button>
                    <button class="overlayBtn" onclick="loadGame(${i})" ${!savedData ? 'disabled' : ''}>Load</button>
                    <button class="overlayBtn" disabled>Export</button>
                </div>
            </div>
        `;
    }

    body.innerHTML = `
        <div style="flex-grow: 1;">${slotsHtml}</div>
        <div style="padding-top: 1rem; text-align: right;">
            <button class="overlayBtn" onclick="importGame()">Import</button>
        </div>
    `;
}

function buildSavesOverlay() {
    const body = document.querySelector('#btnSaves-overlay .overlayBody');
    if (!body) return;

    let slotsHtml = '';
    for (let i = 1; i <= 10; i++) {
        const saveKey = `infestation_save_${i}`;
        const savedData = localStorage.getItem(saveKey);
        let slotName = "Empty Slot";
        let slotDate = "";

        if (savedData) {
            const data = JSON.parse(savedData);
            slotName = data.name;
            slotDate = new Date(data.date).toLocaleString();
        }

        slotsHtml += `
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; border-bottom: 0.0625rem solid #444;">
                <div style="flex-grow: 1;">
                    <span style="font-weight: bold;">${i}: ${slotName}</span>
                    <span style="font-size: 0.8em; color: #aaa; margin-left: 1rem;">${slotDate}</span>
                </div>
                <div>
                    <button class="overlayBtn" onclick="saveGame(${i})">Save</button>
                    <button class="overlayBtn" onclick="loadGame(${i})" ${!savedData ? 'disabled' : ''}>Load</button>
                    <button class="overlayBtn" onclick="exportGame(${i})" ${!savedData ? 'disabled' : ''}>Export</button>
                </div>
            </div>
        `;
    }

    body.innerHTML = `
        <div style="flex-grow: 1;">${slotsHtml}</div>
        <div style="padding-top: 1rem; text-align: right;">
            <button class="overlayBtn" onclick="importGame()">Import</button>
        </div>
    `;
}

function buildCalendar(year, month) { // month is 0-indexed
  const monthYearEl = document.getElementById('calendar-month-year');
  const daysEl = document.getElementById('calendar-days');

  daysEl.innerHTML = ''; // Clear previous days

  const date = new Date(year, month, 1);
  const monthName = date.toLocaleString('default', { month: 'long' });
  monthYearEl.textContent = `${monthName} ${year}`;

  const firstDay = date.getDay(); // 0 for Sunday, 1 for Monday, etc.
  const daysInMonth = new Date(year, month + 1, 0).getDate();

  // Get reminders for the current month for efficiency
  const remindersForMonth = state.journal.reminders.filter(r => {
    const reminderDate = new Date(r.date + 'T00:00:00');
    return reminderDate.getFullYear() === year && reminderDate.getMonth() === month;
  });

  // Create blank cells for the days before the first day of the month
  for (let i = 0; i < firstDay; i++) {
    const dayCell = document.createElement('div');
    dayCell.classList.add('calendar-day', 'other-month');
    daysEl.appendChild(dayCell);
  }

  // Create cells for each day of the month
  for (let i = 1; i <= daysInMonth; i++) {
    const dayCell = document.createElement('div');
    dayCell.classList.add('calendar-day');

    const daySpan = document.createElement('span');
    daySpan.textContent = i;
    dayCell.appendChild(daySpan);

    const fullDate = new Date(year, month, i);
    const currentDate = state.currentTime;

    // Check if it's the current day
    if (fullDate.getFullYear() === currentDate.getFullYear() &&
        fullDate.getMonth() === currentDate.getMonth() &&
        fullDate.getDate() === currentDate.getDate()) {
      dayCell.classList.add('current-day');
    }

    // Check for reminders
    const reminder = remindersForMonth.find(r => {
        const reminderDate = new Date(r.date + 'T00:00:00');
        return reminderDate.getDate() === i;
    });

    if (reminder) {
      dayCell.classList.add('has-reminder');
      dayCell.onclick = () => {
        closeAllOverlays();
        openOverlay('btnJournal');
      };
    }

    // Check for period days
    if (!state.parasite.canImpregnate) { // Only show for normal cycles
        const dayDiff = getDaysBetween(fullDate, state.currentTime);
        const cycleDayForCell = state.menstrualCycle.currentDayInCycle + dayDiff;
        const cycleLength = state.menstrualCycle.cycleLength;
        const periodLength = state.menstrualCycle.periodLength;

        // Normalize the cycle day to be within 1 and cycleLength
        const normalizedCycleDay = ((cycleDayForCell - 1) % cycleLength + cycleLength) % cycleLength + 1;

        if (normalizedCycleDay <= periodLength) {
            dayCell.classList.add('period-day');
        }
    }

    daysEl.appendChild(dayCell);
  }
}

function getSaveStateObject() {
    // 1. Define keys for properties that represent player state and should be saved.
    const stateToSave = [
        'currentTime', 'money', 'eventIndex', 'needs', 'skills', 'sex', 'playerBody',
        'appearance', 'equipment', 'inventory', 'unequippedPiercings', 'stats', 'womb',
        'menstrualCycle', 'pregnancy', 'parasite', 'npcs', 'settings', 'ui',
        'currentLocation', 'locationBeforeEvent'
    ];

    const savedState = {};

    // 2. Selectively copy the state properties into the new object.
    for (const key of stateToSave) {
        if (state.hasOwnProperty(key)) {
            savedState[key] = state[key];
        }
    }

    // 3. Handle the journal separately for forward compatibility.
    savedState.journal = {
        notes: state.journal.notes,
        reminders: state.journal.reminders,
        recurringReminders: state.journal.recurringReminders,
        quests: {} // Save quest *progress* only, not definitions.
    };

    state.journal.quests.forEach(q => {
        savedState.journal.quests[q.title] = {
            complete: q.complete,
            hidden: q.hidden
        };
    });

    return savedState;
}

function saveGame(slotId) {
    const overlay = document.getElementById('save-prompt-overlay');
    const input = document.getElementById('save-name-input');
    const confirmBtn = document.getElementById('save-confirm-btn');
    const cancelBtn = document.getElementById('save-cancel-btn');

    // Check for existing save to pre-fill the name
    const saveKey = `infestation_save_${slotId}`;
    const existingSave = localStorage.getItem(saveKey);
    if (existingSave) {
        input.value = JSON.parse(existingSave).name;
    } else {
        input.value = `Save Slot ${slotId}`;
    }

    // Store the slotId on the button so the handler can access it
    confirmBtn.dataset.slotId = slotId;

    const handleEnterKey = (event) => {
        if (event.key === 'Enter') {
            // Trigger the confirm button's click handler
            confirmBtn.click();
        }
    };
    
    const cleanupAndClose = () => {
        overlay.style.display = 'none';
        input.removeEventListener('keydown', handleEnterKey);
    };

    // Define what the buttons do
    confirmBtn.onclick = () => {
        const newSaveName = input.value.trim();
        if (!newSaveName) {
            alert("Save name cannot be empty.");
            return;
        }

        const saveData = {
            name: newSaveName,
            date: new Date().toISOString(),
            state: state
        };

        try {
            localStorage.setItem(`infestation_save_${slotId}`, JSON.stringify(saveData));
            buildSavesOverlay(); // Refresh the saves screen
            cleanupAndClose(); // Hide prompt and clean up listener
        } catch (e) {
            alert("Error saving game: Your browser's storage might be full.");
            console.error("Save failed: ", e);
        }
    };

    cancelBtn.onclick = cleanupAndClose;
    
    // Show the overlay and add the listener
    input.addEventListener('keydown', handleEnterKey);
    overlay.style.display = 'block';
    input.focus(); // Focus the input field for convenience
}

function loadState(newState) {
    try {
        // A simple deep copy for the main state properties
        Object.keys(newState).forEach(key => {
            if (key === 'currentTime') {
                state.currentTime = new Date(newState.currentTime);
            } else if (key !== 'equipment' && key !== 'inventory') { // Defer hydration
                state[key] = newState[key];
            }
        });

        // Re-hydrate equipment
        const hydratedEquipment = {};
        for (const slotId in newState.equipment) {
            const loadedSlot = newState.equipment[slotId];
            if (!loadedSlot) continue;

            if (loadedSlot.hasOwnProperty('skin')) { // EquipmentSlot
                const newSlot = new EquipmentSlot(loadedSlot.id, loadedSlot.name);
                ['skin', 'middle', 'outer'].forEach(layer => {
                    if (loadedSlot[layer]) {
                        newSlot[layer] = new ClothingItem(loadedSlot[layer]);
                    }
                });
                hydratedEquipment[slotId] = newSlot;
            } else if (loadedSlot.hasOwnProperty('left')) { // HandHeldSlot
                const newSlot = new HandHeldSlot(loadedSlot.name);
                if (loadedSlot.left) newSlot.left = new ClothingItem(loadedSlot.left);
                if (loadedSlot.right) newSlot.right = new ClothingItem(loadedSlot.right);
                hydratedEquipment[slotId] = newSlot;
            } else if (loadedSlot.hasOwnProperty('item')) { // BackSlot
                const newSlot = new BackSlot(loadedSlot.name);
                if (loadedSlot.item) newSlot.item = new ClothingItem(loadedSlot.item);
                hydratedEquipment[slotId] = newSlot;
            } else {
                hydratedEquipment[slotId] = loadedSlot; // Fallback
            }
        }
        state.equipment = hydratedEquipment;

        // Re-hydrate inventory items
        state.inventory = newState.inventory.map(itemData => new ClothingItem(itemData));

        switchScreen('gameScreen');
        fullUiRefresh();
        closeAllOverlays();
    } catch (e) {
        alert("Error loading game state: The save data may be corrupt.");
        console.error("Load failed: ", e);
    }
}

function loadGame(slotId) {
    const saveDataString = localStorage.getItem(`infestation_save_${slotId}`);
    if (!saveDataString) {
        alert("No save data found in this slot.");
        return;
    }

    try {
        const saveData = JSON.parse(saveDataString);
        if (!isSaveDataValid(saveData)) {
            throw new Error("Save data is corrupted or invalid.");
        }
        loadState(saveData.state);
    } catch (e) {
        alert(`Error loading game: ${e.message}`);
        console.error("Load failed: ", e);
    }
}

function exportGame(slotId) {
    const saveDataString = localStorage.getItem(`infestation_save_${slotId}`);
    if (!saveDataString) {
        alert("No save data in this slot to export.");
        return;
    }

    const blob = new Blob([saveDataString], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `infestation_save_${slotId}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function importGame() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.txt,application/json';

    input.onchange = e => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(event) {
            const saveDataString = event.target.result;
            try {
                const saveData = JSON.parse(saveDataString);
                if (!isSaveDataValid(saveData)) {
                    throw new Error("Imported file is not a valid save file.");
                }
                loadState(saveData.state);
            } catch (err) {
                alert(`Failed to import save data: ${err.message}`);
                console.error("Import failed: ", err);
            }
        };
        reader.readAsText(file);
    };

    input.click();
}

function fullUiRefresh() {
    updateHeader();
    updateNeedsUI();
    updateCharDesc();
    initBottomButtons();
    applySettings();
    applyCheatsUI();

    // Re-render the main area based on current location
    if (state.currentLocation === 'event_intro') {
        showCurrentEvent();
    } else {
        renderScene(state.currentLocation);
    }
}

/* ==============================================================
   SKILL SYSTEM UTILS
   ============================================================== */
function getExpForLevel(level) {
  if (level >= 20) return Infinity;
  return 8 * Math.pow(2, level - 1);
}

function addSkillExp(skillName, amount) {
  const skill = state.skills[skillName];
  if (!skill) return;

  // At level 20, you can't gain more exp, but you can lose it.
  if (skill.level >= 20 && amount > 0) {
    skill.exp = getExpForLevel(19); // Ensure it's capped
    return;
  }

  skill.exp += amount;

  // Handle level ups
  let expToLevelUp = getExpForLevel(skill.level);
  while (skill.level < 20 && skill.exp >= expToLevelUp) {
    skill.level++;
    skill.exp -= expToLevelUp;
    expToLevelUp = getExpForLevel(skill.level);
  }

  // Handle level downs
  while (skill.exp < 0) {
    if (skill.level <= 1) {
      skill.exp = 0;
      break;
    }
    skill.level--;
    const expFromPreviousLevel = getExpForLevel(skill.level);
    skill.exp += expFromPreviousLevel;
  }

  // Final check to cap at level 20
  if (skill.level >= 20) {
    skill.level = 20;
    skill.exp = getExpForLevel(19);
  }
}

/* ==============================================================
   CHARACTER WINDOW
   ============================================================== */
function showCharTab(tabName) {
    document.querySelectorAll('.char-tab').forEach(t => t.style.display = 'none');
    const tab = document.getElementById(`char-${tabName}`);
    if (tab) tab.style.display = 'block';

    if (state.ui) {
        state.ui.lastCharTab = tabName;
    }
    
    if (tabName === 'status') updateCharStatusTab();
    else if (tabName === 'skills') updateCharSkillsTab();
    else if (tabName === 'stats') updateCharStatsTab();
    else if (tabName === 'equipment') buildEquipmentTab();
    else if (tabName === 'inventory') buildInventoryTab();
}

function showItemTooltip(event, item, unequipConfig = null) {
    // Prevent the click from propagating to the document and closing the tooltip immediately
    event.stopPropagation();
    
    const tooltip = document.getElementById('sub-overlay');
    const header = tooltip.querySelector('.overlayHeader');
    const body = tooltip.querySelector('.overlayBody');

    // --- 1. Populate Content ---
    const template = clothingTemplates[item.templateId];
    const templateName = template ? template.name : 'Custom Item';
    header.innerHTML = `
        ${item.name} 
        <span style="font-size: 0.8em; color: grey;">(${templateName})</span>
    `;

    let bodyHtml = '<h4>Covers:</h4>';
    if (item.covers && item.covers.length > 0) {
        bodyHtml += '<ul style="list-style-position: inside; padding-left: 1.2rem; margin-top: 0.2rem;">';
        item.covers.forEach(partId => {
            const partName = state.playerBody[partId] ? state.playerBody[partId].name : partId;
            bodyHtml += `<li>${partName}</li>`;
        });
        bodyHtml += '</ul>';
    } else {
        bodyHtml += '<p>Nothing.</p>';
    }

    bodyHtml += '<h4 style="margin-top: 1rem;">Tags:</h4>';
    if (item.tags && item.tags.length > 0) {
        bodyHtml += `<p style="padding: 0 0.5rem; margin-top: 0.2rem;">${item.tags.join(', ')}</p>`;
    } else {
        bodyHtml += '<p>No tags.</p>';
    }
    
    body.innerHTML = bodyHtml;

    // Add unequip and replace buttons if callback is provided
    if (unequipConfig) {
        const buttonContainer = document.createElement('div');
        buttonContainer.style.marginTop = '1rem';
        buttonContainer.style.display = 'flex';
        buttonContainer.style.gap = '0.5rem';

        const unequipBtn = document.createElement('button');
        unequipBtn.textContent = 'Unequip';
        unequipBtn.className = 'overlayBtn';
        unequipBtn.style.flexGrow = '1';
        unequipBtn.onclick = () => {
            unequipItem(unequipConfig.slotId, unequipConfig.subSlot);
            tooltip.style.display = 'none';
        };

        buttonContainer.appendChild(unequipBtn);
        body.appendChild(buttonContainer);
    }
    
    // --- 2. Position Tooltip ---
    tooltip.style.display = 'block';
    positionTooltip(tooltip, event.target);
}

function positionTooltip(tooltipEl, targetEl) {
    const parentOverlay = document.getElementById('btnChar-overlay');
    // If the parent overlay isn't open, something is wrong. Don't position.
    if (!parentOverlay || parentOverlay.style.display !== 'block') {
        tooltipEl.style.display = 'none';
        return;
    }

    const parentRect = parentOverlay.getBoundingClientRect();
    const targetRect = targetEl.getBoundingClientRect();
    const tooltipRect = tooltipEl.getBoundingClientRect();

    // Default position: below the target
    let top = targetRect.bottom + 5;
    let left = targetRect.left;

    // If it doesn't fit below, try to fit it above
    if (top + tooltipRect.height > parentRect.bottom) {
        top = targetRect.top - tooltipRect.height - 5;
    }

    // Now, clamp the vertical position to be within the parent
    if (top < parentRect.top) {
        top = parentRect.top + 5;
    }
    if (top + tooltipRect.height > parentRect.bottom) {
        top = parentRect.bottom - tooltipRect.height - 5;
    }
    
    // Clamp the horizontal position
    if (left < parentRect.left) {
        left = parentRect.left + 5;
    }
    if (left + tooltipRect.width > parentRect.right) {
        left = parentRect.right - tooltipRect.width - 5;
    }

    tooltipEl.style.top = `${top + window.scrollY}px`;
    tooltipEl.style.left = `${left + window.scrollX}px`;
}


function openItemSelectionOverlay(event, slotId, subSlot = null) {
    event.stopPropagation();
    const subOverlay = document.getElementById('sub-overlay');
    const header = subOverlay.querySelector('.overlayHeader');
    const body = subOverlay.querySelector('.overlayBody');

    // Logic change: filter by slot only, not layer.
    const compatibleItems = state.inventory.filter(item => item.slot === slotId);

    let headerText;
    const slot = state.equipment[slotId];
    const slotName = slot ? slot.name : slotId;

    if (slot instanceof EquipmentSlot) { // Layered slots
        headerText = `Select Item for ${slotName} (${subSlot} layer)`;
    } else if (slot instanceof HandHeldSlot) {
        headerText = `Select Item for ${subSlot} hand`;
    } else if (slot instanceof BackSlot) {
        headerText = `Select Item for Back`;
    } else {
        headerText = `Select Item for ${slotName}`; // Fallback
    }

    header.textContent = headerText;
    body.innerHTML = '';

    if (compatibleItems.length === 0) {
        body.innerHTML = '<p>No compatible items in inventory.</p>';
    } else {
        const list = document.createElement('ul');
        compatibleItems.forEach(item => {
            const listItem = document.createElement('li');
            listItem.textContent = item.name;

            const equipBtn = document.createElement('button');
            equipBtn.className = 'overlayBtn';
            equipBtn.style.marginLeft = '1rem';
            equipBtn.textContent = 'Equip';
            equipBtn.onclick = () => {
                equipItem(item.id, subSlot);
                // Manually refresh UI since equipItem doesn't
                buildEquipmentTab();
                updateCharDesc();
                document.getElementById('sub-overlay').style.display = 'none';
            };

            listItem.appendChild(equipBtn);
            list.appendChild(listItem);
        });
        body.appendChild(list);
    }

    // --- Position Tooltip ---
    subOverlay.style.display = 'block';
    positionTooltip(subOverlay, event.target);
}

function buildEquipmentTab() {
    const equipmentDiv = document.getElementById('char-equipment');
    equipmentDiv.innerHTML = ''; // Clear previous content

    // Main container for positioning context
    const container = document.createElement('div');
    container.style.position = 'relative';
    container.style.width = '100%';
    container.style.height = '100%';
    container.style.display = 'flex';
    container.style.justifyContent = 'center';
    container.style.alignItems = 'center';

    // --- ASCII Art as background ---
    const asciiArt = `
                                                                                                                ████████
                                                                                                             ███        ███████████
                                                                                                          ███                      ██
                                                                                                        ███                          ██
                                                                                                      ████                             ██
                                                                                                     ████                               ██
                                                                                                    █████                                ██
                                                                                                   █████                                  ██
                                                                                                  ██████                                   ██
                                                                                                 ██████                                     █
                                                                                                 █████    █                                 ██
                                                                                                ██████   ██                                 ██
                                                                                                ██████   ██                                  ██
                                                                                               ███████  ███                     █             █
                                                                                               ███████ █████                     █            ██
                                                                                              ███████████████                     █            ██
                                                                                             ██████████████████                    █             █
                                                                                            ████████████████████                    ██            █
                                                                                           █████████████████████                    ████          ██
                                                                                           ██████████████    ███                     ████          █
                                                                                           ███████████████   ███                     █████         █
                                                                                           ██████  █████████████                      ███          ██
                                                                                           ████ █  █████████████                    ████          ██
                                                                                            ████ ████████████████                   ███           ██
                                                                                             ██████████████████                    ███            █
                                                                                              █████████████████                   ████           ██
                                                                                              █████████████████                   ███            ██
                                                                                              ██████████████████                  ██             ██
                                                                                         ███ ███████████████████                  ██             ███ ██
                                                                                          ███████████████████████         █       ██           ███████
                                                                                           █████████████████████████████           █           █████
                                                                                              ███████████████████████              ██    █████████
                                                                                                █████████████████                 ████████████████
                                                                                                     ███████████                   ████████████
                                                                                                         ██████                    █
                                                                                                      █████████                     ██
                                                                                                  ████████████                        ██
                                                                                             █████                                      ██████
                                                                                    ███████████                                               ████████
                                                                                 ████                                                                 ████
                                                                              ████                                                                        ██
                                                                             ███                                                                            ██
                                                                            ███                                                                               █
                                                                          ████                                                                                ██
                                                                         ████                                                                                 ██
                                                                        ████                                                                                   ██
                                                                       ████                                                                                    ██
                                                                      ████                                                                                      █
                                                                     ████                                                                                       █
                                                                    ████             ██████                                                                     ██
                                                                  ██████            ████████                                                                    ██
                                                                 █████              █████████                                                        █          █
                                                               ██████              ███████████                                                       █          ██
                                                              ██████               ███████████                                                       █          ██
                                                             █████               █████████████                                                                  █
                                                           █████               ██████ ██████████                                                                █
                                                          ████               ██████    ██████████                                                               ██
                                                        █████               █████       █████████                                                               ██
                                                       ████                ████         ██████████                                                   ██         ██
                                                      ████                ████           ██████████                                                 ███         ██
                                                    █████               ████             ███████████                                                ███         ███
                                                   █████               ████              █████████████                                             ████          ██
                                                  █████              ████                 ███████████████                                       ███████          █
                                                 ████              █████                  ███████████████                                     █████████          ██
                                                ████             █████                     ████████                                               █████          ██
                                               ████             ████                        ███████                                               ██████         █
                                               ███            █████                         ███████                                             ████████          ██
                                              ████            ███                           ███████                                             ████████          █
                                              █████           ██                             ███████                                            ████████          ██
                                              ██████           ██                             ███████                                           ██ █████           █
                                              ██████            ██                            ███████                                           ██  ████           █
                                               ██████            ██                            ██████                                           ██  █████          █
                                                ███████           ██                           ██████                                           ██  █████           █
                                                 ███████           ██                          ██████                                           ██  ██████          █
                                                  ███████           ███                         █████                                           ██  ██████           █
                                                    ██████            ██                        ████                                             ██  ████            █
                                                     ███████           ██                       ████                                              █  ████             █
                                                       ███████          ██                     █████                                              ██ ███              █
                                                        ████████          ██                   █████                                               █████              █
                                                          ████████          ██               ████                                                   █████             ██
                                                            ████████          ██           ███████                           █                       █████             █
                                                              ████████          ██        ███ █████████                                               ████             █
                                                                ███████           ██    ███           ██                                               ███             █
                                                                  ███████           ██████   ██████                                                    ████            ██
                                                                    ██████          █████         ████                                                  ████           ██
                                                                      ██████       ██████   ████     ███                                                 ████          ██
                                                                         █████   ███████    ███████     ███                                              █████         █
                                                                           █████████████████       ████                                                   ████         █
                                                                             ████████████████████                                                          ████        ██
                                                                               █████████████████████                                                       █████       ██
                                                                                 ██████  █████                                                              ████       ██
                                                                                        ██████                                                              █████      █
                                                                                        █████                                                               █████      ██
                                                                                       █████                                                                 ████       █
                                                                                       ████                                                                  █████      █
                                                                                       ████                                                                   ████      █
                                                                                      █████                                                                   ████      █
                                                                                      █████                                                                   █████     ██
                                                                                      █████                                                                   █████     ██
                                                                                     ██████                                                                   █████     ██
                                                                                     ██████                                                                   █████      █
                                                                                    ██████                                                                    █████      ██
                                                                                    ██████                      █                      █                      ██ ██      ██
                                                                                    █████                        █                    █                       ██ ██      ██
                                                                                   ██████                         █  ████         █ ██                        ██ ██      █
                                                                                   ██████                          ██████████████████                         ███        ██
                                                                                  ██████                             ███████████████                          ███        ██
                                                                                  ██████                              █████████████                          ████        ██
                                                                                  █████                               ███   ███████                          ███          █
                                                                                 ██████                               ███   ███████                          ███          ██
                                                                                 ██████                               ███   ███████                         ████          ██
                                                                                 ██████                               ██   █████████                        ████          ██
                                                                                 █████                               ███   █████████                        █████   █      ██
                                                                                ██████                               ███   ████████                        ███ ██  ███     ██
                                                                                ██████                              ███    █████████                       ███ ██    ██   ███
                                                                                ██████                              ███    █████████                      ███  ██  █ ██  ███
                                                                                ██████                             ███     ████████                       ███  ███ ███   ██
                                                                                ██████                            ███      ████████                      ████  ██  ███   ██
                                                                               ██████                             ███      █████████                     ███   █  ███   ██
                                                                               ███████                           ███        ███████                     ████  █████  ████
                                                                               ██████                           ███         ████████                    ███  ████ █████
                                                                               ██████                          ████         ████████                    ███  ███████
                                                                               ██████                          ███          ████████                   ███   ███
                                                                               ██████                         ███           ████████                   ███
                                                                               ██████                        ████           ████████                  ████
                                                                               ██████                       ████            ████████                 ████
                                                                              ███████                      ████             ████████                 ███
                                                                              ███████                      ███              ████████                 ███
                                                                              ███████                     ████              ████████                ███
                                                                              ███████                    ████               ████████                ███
                                                                              ███████                    ████               ████████               ███
                                                                              ███████                   ████               █████████              ████
                                                                              ███████                    ██                ████████               ███
                                                                              ███████                   ███                ████████              ████
                                                                              ███████                   ██                 █████████             ███
                                                                              ████████                 ███                ██████████            ████
                                                                              ████████                 ███                ██████████            ███
                                                                              ███████                 ███                 ███████████          ████
                                                                              ███████                ████                 ███████████          ████
                                                                              ███████                ███                  ███████████         █████
                                                                             ███████                 ███                  ███████████        █████
                                                                             ███████              █  ██                   ███████████       ██████
                                                                            ████████           ███  ███                   ████████████     ███████
                                                                            ████████          ███   ███                   █████████████  █████████
                                                                            ███████          ███    ██                    █████████████ █████████
                                                                           ████████         ██     ███                     ██████████      ██████
                                                                           ████████               ███                      ███████████      █████
                                                                          █████████              ███                       ███████████     ██████
                                                                         ██████████        █    ███                        ████████████   ██  ███
                                                                         ████████              ███                         █████████           ██
                                                                        ██████████            ███                          ████████            ██
                                                                        ████████              ██                          █████████           ███
                                                                       ████████              ███                          █████████           ███
                                                                       ███████              ████                          █████████           ███
                                                                      ███████                ██                          ██████████           ███
                                                                      ███████                ██                          ███████████          ███
                                                                      ██████                 ██                          ██████████          ████
                                                                     ███████                 ██                         █████  ███           ███
                                                                     ███████                ███                         █████  ██            ███
                                                                     ██████                 ██                          █████  ██           ████
                                                                     ██████                 ██                          █████  ██           ███
                                                                     ██████                 ██                          █████  ██           ███
                                                                     █████                 ██                           ██████ ██          ███
                                                                     █████                 ██                           █████████          ███
                                                                     █████                ██                            ████████          ███
                                                                     █████               ██                             █████  █          ███
                                                                     ████                ██                             █████            ███
                                                                     █████              ██                              █████            ███
                                                                    █████             ███                               █████           ███
                                                                    █████             ██                                █████           ███
                                                                    █████            ███                                █████          ███
                                                                    █████            ██                                 █████          ███
                                                                    █████           ██                                  ████          ███
                                                                    █████          ███                                  ████          ███
                                                                    ████           ██                                   ████         ███
                                                                    █████          ██                                   ████         ███
                                                                    █████         ██                                    ████         ██
                                                                    ████          █                                     ████        ██
                                                                     ███         ██                                     ███         ██
                                                                     ███         ██                                     ███        ██
                                                                    ████        ██                                     ████        ██
                                                                    ████        ██                                    ████         ██
                                                                    ████       ██                                     ████        ███
                                                                   █████       ██                                     ████        ██
                                                                   ████        ██                                     ████        ██
                                                                   ████        ██                                     ████        ██
                                                                  ████        ███                                     ████         ██
                                                                 ███          ███                                     █████         █
                                                                ███          ███                                     ███████         ██
                                                              ████           ███                                     ███████          ██
                                                             ████           █████                                    ████████         ███
                                                           █████          ███████                                     ████████          ███
                                                        ██████           ███████                                         █████           █████
                                                      ██████             █████                                             ███                █
                                                    █████               ███                                                ████               ██
                                                    ███                 ██                                                  ██████            ██
                                                   ████               ███                                                    █████            ██
                                                    ████             ███                                                       ████        ███
                                                     █████          ██                                                           ███████████
                                                       █████████████
`;
    const pre = document.createElement('pre');
    pre.textContent = asciiArt;
    pre.style.position = 'absolute';
    pre.style.top = '50%';
    pre.style.left = '45%';
    pre.style.transform = 'translate(-50%, -50%)';
    pre.style.fontSize = '3.55px';
    pre.style.lineHeight = '0.85';
    pre.style.fontFamily = 'monospace';
    pre.style.color = '#0c0';
    pre.style.zIndex = '-1'; // Put it behind the widgets
    container.appendChild(pre);

    // Container for the slot columns
    const slotContainer = document.createElement('div');
    slotContainer.style.display = 'flex';
    slotContainer.style.justifyContent = 'space-between';
    slotContainer.style.width = '100%';
    slotContainer.style.height = '100%';
    slotContainer.style.gap = '1rem';

    // Define columns
    const leftCol = document.createElement('div');
    leftCol.style.flexBasis = '12rem';
    leftCol.style.flexShrink = '0';
    leftCol.style.display = 'flex';
    leftCol.style.flexDirection = 'column';
    leftCol.style.justifyContent = 'flex-start';
    leftCol.style.overflowY = 'auto';
    leftCol.style.gap = '0.5rem'; // Add gap between widgets

    const leftCol2 = document.createElement('div');
    leftCol2.style.flexBasis = '12rem';
    leftCol2.style.flexShrink = '0';
    leftCol2.style.display = 'flex';
    leftCol2.style.flexDirection = 'column';
    leftCol2.style.justifyContent = 'flex-start';
    leftCol2.style.overflowY = 'auto';
    leftCol2.style.gap = '0.5rem'; // Add gap between widgets

    const rightCol = document.createElement('div');
    rightCol.style.flexBasis = '12rem';
    rightCol.style.flexShrink = '0';
    rightCol.style.display = 'flex';
    rightCol.style.flexDirection = 'column';
    rightCol.style.justifyContent = 'flex-start';
    rightCol.style.gap = '0.5rem'; // Add gap between widgets
    rightCol.style.overflowY = 'auto';

    // --- Create and Place Slot Widgets ---
    const createSlotWidget = (slotId) => {
        const slot = state.equipment[slotId];
        const widget = document.createElement('div');
        widget.style.border = '0 solid #444';
        widget.style.padding = '0';
        widget.style.width = '9.375rem';

        const nameDiv = document.createElement('div');
        nameDiv.style.fontWeight = 'bold';
        nameDiv.style.color = '#00ff00';
        nameDiv.style.marginBottom = '0.1rem';
        nameDiv.textContent = slot.name;
        widget.appendChild(nameDiv);

        const createLayerButton = (subSlot, subSlotName) => {
            const item = (slot instanceof BackSlot) ? slot.item : slot[subSlot];
            const button = document.createElement('button');
            
            // New Styling Logic
            button.style.background = '#222';
            button.style.border = '1px solid transparent'; // Dark border, no outline
            button.style.borderRadius = '4px';
            button.style.padding = '.15rem .6rem';
            button.style.cursor = 'pointer';
            button.style.width = '100%';
            button.style.textAlign = 'left';
            button.style.marginBottom = '0.05rem';
            button.style.whiteSpace = 'nowrap';
            button.style.overflow = 'hidden';
            button.style.textOverflow = 'ellipsis';
            
            const originalColor = item ? 'lightblue' : 'grey';
            button.style.color = originalColor;

            button.innerHTML = `<small>[${subSlotName} - ${item ? item.name : 'empty'}]</small>`;
            
            button.onmouseover = () => {
                button.style.color = '#00ff00'; // Green on hover
                button.style.borderColor = '#00ff00';
            };
            button.onmouseout = () => {
                button.style.color = originalColor; // Revert to original color
                button.style.borderColor = 'transparent';
            };

            button.onclick = (event) => {
                if (item) {
                    // Show the new tooltip for equipped items
                    showItemTooltip(event, item, { slotId: slotId, subSlot: subSlot });
                } else {
                    // Open the item selection overlay for empty slots
                    openItemSelectionOverlay(event, slotId, subSlot);
                }
            };
            
            // Add middle-click to unequip
            if (item) {
                button.onauxclick = (event) => {
                    if (event.button === 1) { // Middle mouse button
                        event.preventDefault();
                        unequipItem(slotId, subSlot);
                        document.getElementById('sub-overlay').style.display = 'none'; // Close tooltip
                    }
                };
            }
            widget.appendChild(button);
        };

        if (slot instanceof EquipmentSlot) {
            createLayerButton('skin', 'Skin');
            createLayerButton('middle', 'Middle');
            createLayerButton('outer', 'Outer');
        } else if (slot instanceof HandHeldSlot) {
            createLayerButton('left', 'Left Hand');
            createLayerButton('right', 'Right Hand');
        } else if (slot instanceof BackSlot) {
            createLayerButton('item', 'Back');
        }
        return widget;
    };

    // Add widgets to columns
    leftCol.appendChild(createSlotWidget('neck'));
    leftCol.appendChild(createSlotWidget('arms'));
    leftCol.appendChild(createSlotWidget('hands'));
    leftCol.appendChild(createSlotWidget('legs'));
    leftCol.appendChild(createSlotWidget('hand-held'));

    leftCol2.appendChild(createSlotWidget('back'));

    rightCol.appendChild(createSlotWidget('head'));
    rightCol.appendChild(createSlotWidget('upper'));
    rightCol.appendChild(createSlotWidget('lower'));
    rightCol.appendChild(createSlotWidget('waist'));
    rightCol.appendChild(createSlotWidget('feet'));


    // Create a wrapper for the left columns to group them
    const leftGroup = document.createElement('div');
    leftGroup.style.display = 'flex';
    leftGroup.style.gap = '1rem';
    leftGroup.appendChild(leftCol);
    leftGroup.appendChild(leftCol2);

    // Append the left group and the right column to the main slot container
    slotContainer.appendChild(leftGroup);
    slotContainer.appendChild(rightCol);
    container.appendChild(slotContainer);
    equipmentDiv.appendChild(container);
}

function buildInventoryTab() {
    const inventoryDiv = document.getElementById('char-inventory');
    inventoryDiv.innerHTML = ''; // Clear previous content

    if (state.inventory.length === 0) {
        inventoryDiv.innerHTML = '<p style="padding: 1rem;">Your inventory is empty.</p>';
        return;
    }

    const grid = document.createElement('div');
    grid.className = 'inventory-grid';

    // Sort inventory alphabetically before displaying
    const sortedInventory = [...state.inventory].sort((a, b) => a.name.localeCompare(b.name));

    sortedInventory.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'inventory-item';
        itemDiv.textContent = item.name;
        itemDiv.title = item.name; // Show full name on hover if it's truncated
        itemDiv.onclick = (event) => showItemTooltip(event, item);
        grid.appendChild(itemDiv);
    });

    inventoryDiv.appendChild(grid);
}

function updateCharStatusTab() {
    const statusDiv = document.getElementById('char-status');
    if (!statusDiv) return;

    let html = '<h4>Appearance</h4>';
    html += generateCharacterDescription(state.appearance, state.playerBody, false);
    
    html += '<h4 style="margin-top: 1.5rem;">Tattoos & Piercings</h4>';
    const coverageMap = getCoverageInfo();
    const piercingDescriptions = [];
    const tattooDescriptions = [];

    // Iterate through all body parts to gather piercings.
    Object.values(state.playerBody).forEach(part => {
        if (part.piercings && part.piercings.length > 0) {
            part.piercings.forEach(piercing => {
                const isVisible = !coverageMap.has(part.id);
                const visibleBlue = '#ADD8E6';
                const hiddenBlue = 'lightblue';
                let visibilityHtml = isVisible
                    ? `<span style="color: ${visibleBlue};">It is currently visible.</span>`
                    : `<span style="color: ${hiddenBlue};">It isn't currently visible.</span>`;
                piercingDescriptions.push(`<li>Your ${part.name.toLowerCase()} is pierced with a ${piercing.name}. ${visibilityHtml}</li>`);
            });
        }
    });

    // Iterate through all body parts again to gather tattoos.
    Object.values(state.playerBody).forEach(part => {
        if (part.tattoos && part.tattoos.length > 0) {
            part.tattoos.forEach(tattoo => {
                const isVisible = !coverageMap.has(part.id);
                const isSexual = tattoo.tags.some(t => tattooThemeTags.includes(t) && t !== 'none');
                const exposureRed = '#ff4d4d';
                const visibleBlue = '#ADD8E6';
                const hiddenBlue = 'lightblue';

                let nameHtml = isSexual 
                    ? `<span style="color: ${exposureRed};">"${tattoo.name}"</span>` 
                    : `<span style="color: ${hiddenBlue};">"${tattoo.name}"</span>`;
                
                let visibilityHtml = '';
                if (isVisible) {
                    const color = isSexual ? exposureRed : visibleBlue;
                    visibilityHtml = `<span style="color: ${color};">It is currently visible.</span>`;
                } else {
                    visibilityHtml = `<span style="color: ${hiddenBlue};">It isn't currently visible.</span>`;
                }
                tattooDescriptions.push(`<li>${nameHtml} has been tattooed on your ${part.name.toLowerCase()}. ${visibilityHtml}</li>`);
            });
        }
    });

    const allModsHtml = piercingDescriptions.join('') + tattooDescriptions.join('');

    if (allModsHtml.length > 0) {
        html += '<ul>' + allModsHtml + '</ul>';
    } else {
        html += '<p>You have no body modifications.</p>';
    }

    statusDiv.innerHTML = html;
}

function updateCharSkillsTab() {
    const skillsDiv = document.getElementById('char-skills');
    if (!skillsDiv) return;
    let html = '<div style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;">';

    for (const skillName in state.skills) {
        const skill = state.skills[skillName];
        const expForNextLevel = getExpForLevel(skill.level);
        const progress = skill.level >= 20 ? 100 : Math.round((skill.exp / expForNextLevel) * 100);

        html += `
            <div style="border: 1px solid #444; padding: 0.5rem; width: 120px; box-sizing: border-box; text-align: center;">
                <div style="font-size: 0.8rem;">${skillName}<br>(Lvl ${skill.level})</div>
                <div style="background: #333; height: 10px; margin-top: 5px; border-radius: 2px; overflow: hidden;">
                    <div style="width: ${progress}%; height: 100%; background: lightblue; border-radius: 2px;"></div>
                </div>
            </div>
        `;
    }
    html += '</div>';
    skillsDiv.innerHTML = html;
}

function updateCharStatsTab() {
    const statsDiv = document.getElementById('char-stats');
    if (!statsDiv) return;

    const generalStats = [
        'timesSlept', 'questsCompleted', 'itemsCrafted', 'distanceWalked',
        'timesCollapsedFromStress', 'timesClimaxed'
    ];

    const sexualStats = [
        'vaginalSexCount', 'analSexCount', 'oralSexGivenCount', 'oralSexReceivedCount',
        'vaginalCreampiesReceived', 'analCreampiesReceived', 'oralCreampiesReceived',
        'timesSwallowedSemen', 'totalGirlCumExpelled', 'uniqueSexualPartners'
    ];

    const formatStatName = (statName) => {
        return statName.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase());
    };

    let html = '<h4>General</h4><ul style="list-style-position: inside; margin-top: 0.5rem;">';
    generalStats.forEach(statName => {
        if (state.stats.hasOwnProperty(statName)) {
            html += `<li>${formatStatName(statName)}: ${state.stats[statName]}</li>`;
        }
    });
    html += '</ul>';

    html += '<h4 style="margin-top: 1.5rem;">Sexual</h4><ul style="list-style-position: inside; margin-top: 0.5rem;">';
    sexualStats.forEach(statName => {
        if (state.stats.hasOwnProperty(statName)) {
            html += `<li>${formatStatName(statName)}: ${state.stats[statName]}</li>`;
        }
    });
    html += '</ul>';

    statsDiv.innerHTML = html;
}

/* ==============================================================
   SOCIAL
   ============================================================== */
function buildSocialOverlay() {
    const body = document.querySelector('#btnSocial-overlay .overlayBody');
    if (!body) return;

    let html = '<div class="npc-grid" style="display: flex; flex-wrap: wrap; gap: 1rem; align-content: flex-start; height: 100%; overflow-y: auto;">';

    const knownNpcs = Object.keys(state.npcs).filter(npcName => !state.npcs[npcName].hidden);

    if (knownNpcs.length === 0) {
        html += '<p>You haven\'t met anyone yet.</p>';
    } else {
        for (const npcName of knownNpcs) {
            const npc = state.npcs[npcName];

            html += `<div class="npc-plate" style="border: 1px solid #444; padding: 1rem; width: 22%; box-sizing: border-box; min-height: 160px; display: flex; flex-direction: column; justify-content: space-between;">`;

            html += `<div><h4>${npcName}</h4>`;

            // Always show stats for visible NPCs
            html += createNpcStatBar('Love', npc.relationship, '#ff0000'); // Red
            html += createNpcStatBar('Lust', npc.attraction, '#ff69b4');   // Hot Pink
            html += createNpcStatBar('Trust', npc.trust, '#1e90ff');     // Dodger Blue
            html += createNpcStatBar('Fear', npc.fear, '#9932cc');       // Dark Orchid
            
            html += `</div></div>`; // Close h4 div and npc-plate
        }
    }
    html += '</div>';

    body.innerHTML = html;
}

function createNpcStatBar(statName, value, barColor = '#4a90e2') {
    const percentage = Math.max(0, Math.min(100, value));

    return `
        <div class="npc-stat-bar-container" style="display: flex; align-items: center; margin-bottom: 0.3rem;">
            <span style="width: 80px; font-size: 0.9em; text-align: right; margin-right: 5px;">${statName}</span>
            <div class="bar" style="flex-grow: 1; height: 8px; background: #444; border-radius: 2px;">
                <div class="fill" style="width: ${percentage}%; height: 100%; background: ${barColor}; border-radius: 2px;"></div>
            </div>
        </div>
    `;
}
function cheatAddAllSkillsExp(amount) {
    for (const skillName in state.skills) {
        addSkillExp(skillName, amount);
    }
    // Visually update the character screen if it's open
    if (document.getElementById('btnChar-overlay').style.display === 'block') {
        updateCharSkillsTab();
    }
}

function cheatAddSkillExp(skillName, amount) {
    addSkillExp(skillName, amount);
    buildCheatOverlay();
    if (document.getElementById('btnChar-overlay').style.display === 'block') {
        updateCharSkillsTab();
    }
}



/* ==============================================================
   HEADER (date | time | money)
   ============================================================== */
function updateHeader(){
  document.getElementById('clock').textContent = fmtHM(state.currentTime);
  document.getElementById('date' ).textContent = fmtDate(state.currentTime);
  document.getElementById('money').textContent = formatMoney(state.money);
}

/* ==============================================================
   NEEDS UI
   ============================================================== */
function getFillPct(k){
  const cur = state.needs[k];
  const max = state.ranges[k];
  return Math.min(100, Math.max(0, (cur / max) * 100));
}

/* Simple stage labels (just for visual flavour) */
function stageLabel(p){
  if(p===0) return 'Stage 0';
  if(p<=33) return 'Stage 1';
  if(p<=66) return 'Stage 2';
  if(p<=99) return 'Stage 3';
  if(p=100) return 'Stage 4';
}

function updateNeedsUI(){
  Object.keys(state.needs).forEach(k=>{
    const el   = document.getElementById(`need-${k}`);
    if(!el) return;

    const pct  = getFillPct(k);                     // 0‑100 %
    const fill = el.querySelector('.fill');
    const line = el.querySelector('.needLine');

/* ---------- colour (custom logic) ---------- */
const inverted = ['stress','trauma','arousal'].includes(k);
const barColor =
  k === 'corruption' ? 'purple' :
  k === 'alcohol' ? 'orange' :
  k === 'drugs' ? 'lightsalmon' :
  (() => {
    const r = Math.round(255 * (inverted ? pct/100 : 1-pct/100));
    const g = Math.round(255 * (inverted ? 1-pct/100 : pct/100));
    return `rgb(${r},${g},0)`;
  })();

    fill.style.width = pct + '%';
    fill.style.background = barColor;               // thin bar colour
    

    /* ---------- stage label ---------- */
    const labels = el.getAttribute('data-labels').split('|');
    const labelRangesAttr = el.getAttribute('data-label-ranges');
    let stage;

    if (labelRangesAttr) {
        // New system with custom, expandable ranges
        const ranges = labelRangesAttr.split(',').map(Number);
        let labelIndex = -1;

        for (let i = 0; i < ranges.length; i++) {
            if (pct <= ranges[i]) {
                labelIndex = i;
                break;
            }
        }

        if (labelIndex === -1) {
            labelIndex = labels.length - 1;
        }

        stage = labels[labelIndex];
    } else {
        // Original system for backward compatibility
        const idx = Math.min(labels.length-1, Math.floor(pct/20)); // 0‑4
        stage = labels[idx];
    }

    /* ---------- compose “Name: Stage” line ----------
       – for normal needs we show the name, for hidden ones we hide it
    */
    const needName = el.getAttribute('data-name');
    if(el.classList.contains('noName')){
      // hidden needs: only the stage (no name)
      line.innerHTML = `<span class="stage" style="color:${barColor};">${stage}</span>`;
    }else{
      // normal needs: “Name: Stage” on one line
      line.innerHTML = `
        <span style="color:#fff;">${needName}:</span>
        <span class="stage" style="color:${barColor}; margin-left:.4rem;">${stage}</span>
      `;
    }

    /* ---------- tooltip (name white + % coloured) ---------- */
    const tooltip = el.querySelector('.tooltip');
    tooltip.innerHTML = `
      <span style="color:#fff;">${needName}</span>
      <span style="color:${barColor}; margin-left:.4rem;">${pct.toFixed(0)}%</span>
    `;

    /* ---------- empty‑text colour handling (unchanged) ---------- */
    if(!inverted && pct===0 && !el.classList.contains('noName')){
      line.classList.add('empty');
    }else{
      line.classList.remove('empty');
    }
  });

  /* ---- visibility of the “bad” needs (unchanged) ---- */
  document.getElementById('need-alcohol')
          .style.display = state.needs.alcohol>0 ? 'block' : 'none';
  document.getElementById('need-drugs')
          .style.display = state.needs.drugs>0 ? 'block' : 'none';

  const corr = document.getElementById('need-corruption');
  if(state.showCorruption){
    corr.classList.remove('hiddenBar');
    corr.style.display = 'block';
  }else{
    corr.classList.add('hiddenBar');
    corr.style.display = 'none';
  }
}

/* ==============================================================
   SCREEN SWITCHING
   ============================================================== */
function switchScreen(id){
  document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

/* ==============================================================
   INTRO EVENT SEQUENCE (no time advance while reading)
   ============================================================== */
function showCurrentEvent(){
  const c = document.getElementById('mainArea');
  c.innerHTML = '';

  const ev = state.events[state.eventIndex];

  if (ev.reveals && state.npcs[ev.reveals]) {
    state.npcs[ev.reveals].hidden = false;
  }

  const title = document.createElement('h2');
  title.className = 'eventTitle';
  title.textContent = ev.title;
  c.appendChild(title);

  const txt = document.createElement('p');
  txt.className = 'eventText';
  txt.textContent = ev.text;
  c.appendChild(txt);

  const link = document.createElement('span');
  link.className = 'link';
  link.textContent = (state.eventIndex < state.events.length-1) ? 'Continue →' : 'Enter the Lab →';
  link.onclick = () => {
    if(state.eventIndex < state.events.length-1){
      state.eventIndex++;
      showCurrentEvent();          // **no** advanceTime here
    }else{
      state.storyEventActive = false; // Intro is over
      goToScene('foyer', 30);      // entering the lab starts the map
    }
  };
  c.appendChild(link);
}

/* ==============================================================
   MAP – FOYER AND ROOMS (each move advances time)
   ============================================================== */
function renderScene(sceneName) {
  state.currentLocation = sceneName;
  const sceneData = state.scenes[sceneName];
  if (!sceneData) return; // Or show an error scene

  const c = document.getElementById('mainArea');
  c.innerHTML = `
    <h2 class="eventTitle">${sceneData.title}</h2>
    <p class="eventText" id="sceneDesc">${sceneData.description}</p>
    <div class="navColumn" id="sceneNav"></div>
  `;

  const nav = document.getElementById('sceneNav');
  let navHtml = '';
  sceneData.nav.forEach(link => {
    let showLink = true;
    if (link.condition) {
      if (link.condition.type === 'npc_relationship') {
        const npc = state.npcs[link.condition.npc];
        if (!npc || npc.relationship < link.condition.value) {
          showLink = false;
        }
      } else if (link.condition.type === 'parasite_impregnate_enabled') {
        if (!state.parasite.canImpregnate) {
            showLink = false;
        }
      } else if (link.condition.type === 'worms_ready_to_birth') {
        const now = state.currentTime.getTime();
        const readyWorms = state.parasite.worms.filter(worm => now >= worm.birthReadyTime);
        if (readyWorms.length === 0) {
            showLink = false;
        }
      }
      // Future condition types can be added here
    }

    if (showLink) {
      navHtml += `<span class="link" onclick="${link.action}">${link.text}</span>`;
    }
  });
  nav.innerHTML = navHtml;

  positionNavBelow(document.getElementById('sceneDesc'), nav);
}

function goToScene(sceneName, seconds) {
  if (seconds > 0) {
    advanceTime(seconds);
  }

  // --- NEW RANDOM EVENT LOGIC ---
  const destinationScene = state.scenes[sceneName];
  if (destinationScene && destinationScene.randomEvents) {
    for (const event of destinationScene.randomEvents) {
      const conditionMet = checkEventCondition(event.condition);
      if (conditionMet && Math.random() < event.chance) {
        // The random event triggered!
        renderScene(event.scene); // Go to the event scene instead
        return; // Stop processing further
      }
    }
  }

  // If no random event triggered, render the original destination
  renderScene(sceneName);
}

function finishShower() {
  advanceTime(600); // 10 minutes
  goToScene('bathroom', 0);
}

function finishRelaxing() {
  // 1. Pass time, but don't update the UI yet
  advanceTime(1800, false);

  // 2. Apply the stat bonuses
  let newHappiness = state.needs.happiness + 50;
  if (newHappiness > state.ranges.happiness) {
    newHappiness = state.ranges.happiness;
  }
  state.needs.happiness = newHappiness;

  let newTiredness = state.needs.tiredness + 250;
  if (newTiredness > state.ranges.tiredness) {
    newTiredness = state.ranges.tiredness;
  }
  state.needs.tiredness = newTiredness;

  // 3. Now, update the UI with the final values
  forceGlobalUIRefresh();
  checkStatTriggers();

  // 4. Go back to the lounge
  goToScene('lounge', 0);
}

function recoverFromStressCollapse() {
  // Set stress to 35% and increase trauma by 10%
  state.needs.stress = state.ranges.stress * 0.35;
  state.needs.trauma = Math.min(state.ranges.trauma, state.needs.trauma + (state.ranges.trauma * 0.1));
  state.stats.timesCollapsedFromStress++;
  state.storyEventActive = false;

  // Go back to the previous location after a 1-hour time penalty
  goToScene(state.locationBeforeEvent, 3600);
}

function recoverFromArousalMax() {
  // Reset arousal and increment counter
  state.needs.arousal = 0;
  state.stats.timesClimaxed++;
  state.storyEventActive = false;

  // Go back to the previous location after a 10-minute time penalty
  goToScene(state.locationBeforeEvent, 600);
}

function handleMorningSickness() {
    state.needs.happiness = Math.max(0, state.needs.happiness - 25);
    state.needs.stress = Math.min(state.ranges.stress, state.needs.stress + 50);
    forceGlobalUIRefresh();
    goToScene('bathroom', 0); // Return to the bathroom
}

function handleParasiteCraving() {
    state.needs.stress = Math.min(state.ranges.stress, state.needs.stress + 75);
    state.needs.corruption = Math.min(state.ranges.corruption, state.needs.corruption + 5);
    forceGlobalUIRefresh();
    goToScene('kitchen', 0); // Return to the kitchen
}

function passDayInLounge() {
    advanceTime(86400); // 24 hours
    state.needs.tiredness = state.ranges.tiredness;
    state.needs.happiness = state.ranges.happiness;
    forceGlobalUIRefresh(); // Update UI to show maxed stats
    // Player remains in the lounge, scene does not need to be re-rendered.
}

/* Helper – positions a .navColumn just below a given element */
function positionNavBelow(targetEl, navEl){
  const parent = document.getElementById('mainArea').getBoundingClientRect();
  const tgt    = targetEl.getBoundingClientRect();
  const pct = ((tgt.bottom - parent.top) / parent.height) * 100;
  navEl.style.top = `${pct + 2}%`;   // small gap
}

function goToTailorHub() {
    closeAllOverlays();
    const overlay = document.getElementById('tailor-hub-overlay');
    const buttonsContainer = document.getElementById('tailor-slot-buttons');
    buttonsContainer.innerHTML = ''; // Clear previous buttons

    for (const slotId in state.equipment) {
        // Hand-held is excluded for now as there are no craftable hand-held templates.
        // This avoids showing the player a button that leads to an empty crafting screen.
        if (slotId !== 'hand-held') {
            const slot = state.equipment[slotId];
            const button = document.createElement('button');
            button.className = 'overlayBtn';
            button.textContent = slot.name;
            button.onclick = () => openCraftingOverlay(slotId);
            buttonsContainer.appendChild(button);
        }
    }
    overlay.style.display = 'block';
}

function backToTailorHub() {
    // This function will be called from the crafting overlay to go back to the hub
    document.getElementById('tailor-crafting-overlay').style.display = 'none';
    goToTailorHub();
}

function openBodyArtStudio() {
    closeAllOverlays();
    const overlay = document.getElementById('body-art-studio-overlay');
    overlay.style.display = 'block';

    // Populate body part dropdown for tattoos, in the correct order
    const tattooPartSelect = document.getElementById('tattoo-body-part-select');
    const allTattooParts = bodyPartOrder.filter(p => tattooTemplates[p]);
    tattooPartSelect.innerHTML = allTattooParts.map(partId => `<option value="${partId}">${state.playerBody[partId].name}</option>`).join('');

    // Set default tab and populate its content
    showBodyArtTab('tattoos');
}

function showBodyArtTab(tabName) {
    document.querySelectorAll('.body-art-tab').forEach(tab => tab.style.display = 'none');
    document.getElementById(`body-art-tab-${tabName}`).style.display = 'flex';

    if (tabName === 'tattoos') {
        onTattooPartSelect();
        populateCurrentTattoos();
    } else if (tabName === 'piercings') {
        initPiercingTab();
    }
}

function removeTattoo(tattooId, bodyPartId) {
    const removalCost = 5000;
    if (state.money < removalCost) {
        showErrorNotification("You can't afford the removal fee.");
        return;
    }
    const bodyPart = state.playerBody[bodyPartId];
    if (!bodyPart) return;

    const tattooIndex = bodyPart.tattoos.findIndex(t => t.id === tattooId);
    if (tattooIndex > -1) {
        state.money -= removalCost;
        bodyPart.tattoos.splice(tattooIndex, 1);
        forceGlobalUIRefresh();
        populateCurrentTattoos(); // Refresh the removal list
    }
}

function onTattooPartSelect() {
    const partId = document.getElementById('tattoo-body-part-select').value;
    const templateNameEl = document.getElementById('tattoo-template-name');
    const tagsWrapper = document.getElementById('tattoo-tags-sections-wrapper');
    const nameInput = document.getElementById('tattoo-name-input');

    const template = tattooTemplates[partId] || tattooTemplates['custom_text']; // Fallback to custom text
    
    if (!template) {
        // This should not happen if all body parts are covered
        tagsWrapper.style.display = 'none';
        templateNameEl.textContent = 'N/A';
        updateTattooPreview();
        return;
    }

    // Set the template name and show the tags
    templateNameEl.textContent = template.name;
    tagsWrapper.style.display = 'flex';
    nameInput.value = ''; // Clear name input on part change

    const createCheckboxes = (containerId, tags, category) => {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        if (!template.allowedTags) {
            document.getElementById(containerId.replace('-tags-container', '-section')).style.display = 'none';
            return;
        }
        const allowed = tags.filter(tag => template.allowedTags.includes(tag));
        if (allowed.length === 0) {
            document.getElementById(containerId.replace('-tags-container', '-section')).style.display = 'none';
            return;
        }
        document.getElementById(containerId.replace('-tags-container', '-section')).style.display = 'block';

        allowed.forEach(tag => {
            const label = document.createElement('label');
            const inputEl = document.createElement('input');
            inputEl.type = (category === 'theme') ? 'radio' : 'checkbox';
            inputEl.name = `tattoo-tag-${category}`;
            inputEl.value = tag;
            inputEl.onclick = () => updateTattooPreview();
            if (template.forcedTags && template.forcedTags.includes(tag)) {
                inputEl.checked = true;
                inputEl.disabled = true;
            }
            label.appendChild(inputEl);
            label.appendChild(document.createTextNode(` ${tag}`));
            container.appendChild(label);
        });
    };

    createCheckboxes('tattoo-style-tags-container', tattooStyleTags, 'style');
    createCheckboxes('tattoo-feature-tags-container', tattooFeatureTags, 'feature');
    createCheckboxes('tattoo-size-tags-container', tattooSizeTags, 'size');
    createCheckboxes('tattoo-theme-tags-container', tattooThemeTags, 'theme');
    
    const textSection = document.getElementById('tattoo-text-section');
    const isCustomText = template.baseDesign.includes('{text}');
    textSection.style.display = isCustomText ? 'block' : 'none';
    if (isCustomText) {
        document.getElementById('tattoo-custom-text').value = '';
    }

    updateTattooPreview();
}


function updateTattooPreview() {
    const partId = document.getElementById('tattoo-body-part-select').value;
    const template = tattooTemplates[partId] || tattooTemplates['custom_text'];
    
    const designEl = document.getElementById('tattoo-preview-design');
    const tagsEl = document.getElementById('tattoo-final-tags-list');
    const costBtn = document.getElementById('get-tattoo-btn');
    
    designEl.textContent = '';
    tagsEl.innerHTML = '';
    costBtn.textContent = 'Get Tattoo';
    costBtn.disabled = true;

    if (!template) return;

    const finalTags = new Set(template.forcedTags || []);
    let finalCost = template.baseCost;

    document.querySelectorAll('#tattoo-tags-sections-wrapper input:checked').forEach(cb => {
        finalTags.add(cb.value);
    });

    let finalDesign = template.baseDesign;
    if (finalDesign.includes('{text}')) {
        const customText = document.getElementById('tattoo-custom-text').value;
        if (customText) {
            finalDesign = finalDesign.replace('{text}', `"${customText}"`);
        } else {
            finalDesign = finalDesign.replace('{text}', '..._');
        }
    }

    finalTags.forEach(tag => {
        if (tattooTagPrices[tag]) {
            finalCost += tattooTagPrices[tag];
        }
    });

    designEl.textContent = finalDesign;
    const displayTags = Array.from(finalTags).filter(t => t !== 'none');
    tagsEl.innerHTML = displayTags.sort().map(tag => `<li>${tag}</li>`).join('');
    costBtn.textContent = `Get Tattoo (${formatMoney(finalCost)})`;
    costBtn.disabled = false;
    costBtn.dataset.cost = finalCost;
}

function getTattoo() {
    const partId = document.getElementById('tattoo-body-part-select').value;
    const name = document.getElementById('tattoo-name-input').value.trim();
    const cost = parseFloat(document.getElementById('get-tattoo-btn').dataset.cost);
    
    if (!name) {
        showErrorNotification("Please enter a name for your tattoo.");
        return;
    }

    // Mandatory tag check
    const selectedTagsSet = new Set(Array.from(document.querySelectorAll('#tattoo-tags-sections-wrapper input:checked')).map(cb => cb.value));
    const checkCategory = (sectionId, tagArray, categoryName) => {
        const section = document.getElementById(sectionId);
        if (section.style.display !== 'none' && !tagArray.some(tag => selectedTagsSet.has(tag))) {
            showErrorNotification(`Please select at least one ${categoryName} for your tattoo.`);
            return false;
        }
        return true;
    };

    if (!checkCategory('tattoo-style-section', tattooStyleTags, 'Style')) return;
    if (!checkCategory('tattoo-feature-section', tattooFeatureTags, 'Feature')) return;
    if (!checkCategory('tattoo-size-section', tattooSizeTags, 'Size')) return;
    if (!checkCategory('tattoo-theme-section', tattooThemeTags, 'Theme')) return;

    if (!partId) {
        showErrorNotification("Please select a body part.");
        return;
    }
    if (state.money < cost) {
        showErrorNotification("You don't have enough money.");
        return;
    }

    // Check if body part already has a tattoo
    if (state.playerBody[partId].tattoos.length > 0) {
        showErrorNotification("This body part already has a tattoo. Please remove the existing one first.");
        return;
    }

    const design = document.getElementById('tattoo-preview-design').textContent;
    const tagsList = document.getElementById('tattoo-final-tags-list');
    let tags = Array.from(tagsList.querySelectorAll('li')).map(li => li.textContent);

    // Filter out the 'none' tag if it exists
    if (tags.includes('none')) {
        tags = tags.filter(t => t !== 'none');
    }

    state.money -= cost;
    const newTattoo = new TattooItem({
        id: `tattoo_${Date.now()}`,
        name: name,
        design: design,
        tags: tags
    });
    
    state.playerBody[partId].tattoos.push(newTattoo);
    
    forceGlobalUIRefresh();
    populateCurrentTattoos();
}

function populateCurrentTattoos() {
    const container = document.getElementById('current-tattoos-container');
    container.innerHTML = '';
    let hasTattoos = false;

    for (const partId in state.playerBody) {
        const part = state.playerBody[partId];
        if (part.tattoos && part.tattoos.length > 0) {
            hasTattoos = true;
            part.tattoos.forEach(tattoo => {
                const div = document.createElement('div');
                div.style.display = 'flex';
                div.style.justifyContent = 'space-between';
                div.style.marginBottom = '0.5rem';
                div.innerHTML = `<span>${tattoo.name} on your ${part.name}</span>`;

                const removeBtn = document.createElement('button');
                removeBtn.className = 'overlayBtn';
                removeBtn.textContent = 'Remove';
                removeBtn.onclick = () => removeTattoo(tattoo.id, partId);
                
                div.appendChild(removeBtn);
                container.appendChild(div);
            });
        }
    }

    if (!hasTattoos) {
        container.innerHTML = '<p>You have no tattoos.</p>';
    }
}


const availableTags = ['athletic', 'bag', 'belly hiding', 'belly showing', 'business', 'casual', 'cool', 'costume', 'cotton', 'denim', 'fetish-wear', 'fishnet', 'formal', 'goth', 'high heeled', 'lace', 'latex', 'leather', 'metal', 'nylon', 'plastic', 'polyester', 'satin', 'sexy', 'silk', 'spandex', 'swimming', 'transparent', 'underwear', 'vinyl', 'wool'];

const materialTags = ['cotton', 'denim', 'fishnet', 'lace', 'latex', 'leather', 'metal', 'nylon', 'plastic', 'polyester', 'satin', 'silk', 'spandex', 'vinyl', 'wool'];
const styleTags = ['athletic', 'business', 'casual', 'cool', 'fetish-wear', 'formal', 'goth', 'sexy'];
const generalTags = ['bag', 'belly hiding', 'belly showing', 'costume', 'high heeled', 'swimming', 'transparent', 'underwear'];

const mutuallyExclusiveTags = [
    ['belly showing', 'belly hiding']
];

const slotSpecificTags = {
    'high heeled': ['feet']
};

function openCraftingOverlay(slotId) {
    document.getElementById('tailor-hub-overlay').style.display = 'none';
    const overlay = document.getElementById('tailor-crafting-overlay');
    const templateSelect = document.getElementById('tailor-template-select');
    const nameInput = document.getElementById('tailor-item-name');
    const tagsWrapper = document.getElementById('tailor-tags-sections-wrapper');

    // Store the current slot in the element for the craft button to use
    overlay.dataset.slotId = slotId;

    // Clear previous content and reset UI state
    templateSelect.innerHTML = '<option value="">--Please choose a template--</option>';
    nameInput.value = '';
    nameInput.disabled = true;
    tagsWrapper.style.display = 'none'; // Hide the tag sections initially

    // Populate templates based on the selected slot
    const templates = Object.values(clothingTemplates).filter(t => t.slot === slotId);
    templates.forEach(template => {
        const option = document.createElement('option');
        option.value = template.id;
        option.textContent = template.name;
        templateSelect.appendChild(option);
    });

    onTemplateSelect(); // Call this to ensure the UI is in a clean initial state
    overlay.style.display = 'block';
}

function onTemplateSelect() {
    const templateSelect = document.getElementById('tailor-template-select');
    const nameInput = document.getElementById('tailor-item-name');
    const tagsWrapper = document.getElementById('tailor-tags-sections-wrapper');
    const coverageList = document.getElementById('tailor-coverage-list');

    // Get containers for new UI
    const materialSection = document.getElementById('tailor-material-section');
    const materialSelect = document.getElementById('tailor-material-select');
    const styleContainer = document.getElementById('tailor-style-tags-container');
    const generalContainer = document.getElementById('tailor-general-tags-container');

    const selectedTemplateId = templateSelect.value;

    // 1. Reset everything to a clean slate.
    coverageList.innerHTML = '';
    materialSelect.innerHTML = '';
    styleContainer.innerHTML = '';
    generalContainer.innerHTML = '';

    if (!selectedTemplateId) {
        nameInput.value = '';
        nameInput.disabled = true;
        tagsWrapper.style.display = 'none';
        updateFinalTagsList();
        updateCraftingCost(); // Update cost to reset button
        return;
    }

    // 2. A template is selected, so enable UI.
    nameInput.disabled = false;
    tagsWrapper.style.display = 'flex'; // Show the whole tag section
    const template = clothingTemplates[selectedTemplateId];
    nameInput.value = template.name;

    const allowed = template.allowedTags || [];
    const forced = template.forcedTags || [];

    // 3. Populate Materials Dropdown
    const availableMaterials = materialTags.filter(t => allowed.includes(t));
    let hasForcedMaterial = false;
    if (availableMaterials.length > 0) {
        materialSelect.innerHTML = '<option value="">-- a material --</option>';
        availableMaterials.forEach(tag => {
            const option = document.createElement('option');
            option.value = tag;
            option.textContent = tag;
            if (forced.includes(tag)) {
                option.selected = true;
                hasForcedMaterial = true;
            }
            materialSelect.appendChild(option);
        });
        materialSection.style.display = hasForcedMaterial ? 'none' : 'block';
    } else {
        materialSection.style.display = 'none';
    }
    materialSelect.onchange = updateTagAvailability;

    // 4. Populate Style & General Checkboxes
    const createCheckbox = (tag, container) => {
        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'center';
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.name = 'tailor-tag';
        checkbox.value = tag;
        checkbox.checked = forced.includes(tag);
        checkbox.onclick = updateTagAvailability;
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(` ${tag}`));
        container.appendChild(label);
    };

    styleTags.filter(t => allowed.includes(t)).forEach(t => createCheckbox(t, styleContainer));
    generalTags.filter(t => allowed.includes(t)).forEach(t => createCheckbox(t, generalContainer));

    // 5. Populate coverage list and update UI
    updateCoverageList();
    updateTagAvailability();
}

function updateCoverageList() {
    const coverageList = document.getElementById('tailor-coverage-list');
    const template = clothingTemplates[document.getElementById('tailor-template-select').value];
    coverageList.innerHTML = '';
    if (!template || !template.covers) return;

    let finalCovers = [...template.covers];

    // Check if 'belly showing' is selected
    const bellyShowingCheckbox = document.querySelector('input[name="tailor-tag"][value="belly showing"]');
    if (bellyShowingCheckbox && bellyShowingCheckbox.checked) {
        const bellyIndex = finalCovers.indexOf('belly');
        if (bellyIndex > -1) {
            finalCovers.splice(bellyIndex, 1);
        }
    }

    // Check for transparent and fetish-wear to update the live preview
    const transparentCheckbox = document.querySelector('input[name="tailor-tag"][value="transparent"]');
    const fetishCheckbox = document.querySelector('input[name="tailor-tag"][value="fetish-wear"]');

    if (transparentCheckbox && transparentCheckbox.checked) {
        finalCovers.length = 0; // Clear the array
    } else if (fetishCheckbox && fetishCheckbox.checked) {
        const partsToExpose = ['vagina', 'left_nipple', 'right_nipple'];
        let i = finalCovers.length;
        while (i--) {
            if (partsToExpose.includes(finalCovers[i])) {
                finalCovers.splice(i, 1);
            }
        }
    }

    // Populate the list
    finalCovers.forEach(partName => {
        const li = document.createElement('li');
        li.textContent = state.playerBody[partName] ? state.playerBody[partName].name : partName;
        coverageList.appendChild(li);
    });
}

function updateTagAvailability() {
    const allCheckboxes = Array.from(document.querySelectorAll('input[name="tailor-tag"]'));
    const template = clothingTemplates[document.getElementById('tailor-template-select').value];
    if (!template) return;

    const forced = template.forcedTags || [];
    const allowed = template.allowedTags || [];

    // Enable all allowed checkboxes first
    allCheckboxes.forEach(cb => {
        cb.disabled = !allowed.includes(cb.value);
    });

    // Disable based on mutual exclusion
    const checkedTags = allCheckboxes.filter(cb => cb.checked).map(cb => cb.value);
    checkedTags.forEach(checkedTag => {
        const exclusionGroup = mutuallyExclusiveTags.find(group => group.includes(checkedTag));
        if (exclusionGroup) {
            exclusionGroup.forEach(tagToDisable => {
                if (tagToDisable !== checkedTag) {
                    const checkboxToDisable = allCheckboxes.find(cb => cb.value === tagToDisable);
                    if (checkboxToDisable) checkboxToDisable.disabled = true;
                }
            });
        }
    });

    // Finally, disable all forced tags so they can't be unchecked
    forced.forEach(forcedTag => {
        const checkbox = allCheckboxes.find(cb => cb.value === forcedTag);
        if (checkbox) checkbox.disabled = true;
    });

    updateFinalTagsList();
    updateCraftingCost();
    setTimeout(updateCoverageList, 0);
}

let notificationTimeout;
function showCraftNotification(itemName, templateName) {
    const notification = document.getElementById('craft-notification-overlay');
    if (!notification) return;

    // Clear any existing timeout to prevent overlaps
    clearTimeout(notificationTimeout);

    notification.innerHTML = `
        '${itemName}'
        <span style="font-size: 0.8em; color: #333;">(${templateName})</span>
        <br>added to inventory!
    `;
    
    notification.style.display = 'block';
    // Use a tiny timeout to allow the display property to apply before changing opacity for the transition
    setTimeout(() => {
        notification.style.opacity = '1';
    }, 10);

    // Set timeout to fade out and then hide
    notificationTimeout = setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.style.display = 'none';
        }, 400); // This should match the CSS transition duration
    }, 2500);
}

let errorNotificationTimeout;
function showErrorNotification(message) {
    const notification = document.getElementById('error-notification-overlay');
    if (!notification) return;

    clearTimeout(errorNotificationTimeout);
    notification.textContent = message;

    notification.style.display = 'block';
    setTimeout(() => {
        notification.style.opacity = '1';
    }, 10);

    errorNotificationTimeout = setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
            notification.style.display = 'none';
        }, 400);
    }, 1500);
}

function updateFinalTagsList() {
    const finalTagsList = document.getElementById('tailor-final-tags-list');
    const template = clothingTemplates[document.getElementById('tailor-template-select').value];
    finalTagsList.innerHTML = '';
    if (!template) return;

    const finalTags = new Set(template.tags || []);

    // Add selected material
    const materialSelect = document.getElementById('tailor-material-select');
    if (materialSelect.value) {
        finalTags.add(materialSelect.value);
    }

    // Add checked tags
    document.querySelectorAll('input[name="tailor-tag"]:checked').forEach(cb => {
        finalTags.add(cb.value);
    });

    Array.from(finalTags).sort().forEach(tag => {
        const li = document.createElement('li');
        li.textContent = tag;
        finalTagsList.appendChild(li);
    });
}

const tagPrices = {
    'leather': 75,
    'silk': 100,
    'wool': 60,
    'metal': 80,
    'jewelry': 50,
    'fetish-wear': 40,
    'lace': 30,
    'satin': 35,
    'vinyl': 45
};

function updateCraftingCost() {
    const craftButton = document.getElementById('craft-item-btn');
    const templateSelect = document.getElementById('tailor-template-select');
    const selectedTemplateId = templateSelect.value;

    if (!selectedTemplateId) {
        craftButton.textContent = 'Craft Item';
        craftButton.disabled = true;
        return;
    }

    const template = clothingTemplates[selectedTemplateId];
    const fallbackMaterialPrice = 50;
    const fallbackTagPrice = 15;

    // --- Gather all final tags for the item ---
    const finalTags = new Set(template.tags || []);
    if (template.forcedTags) {
        template.forcedTags.forEach(tag => finalTags.add(tag));
    }
    const materialSelect = document.getElementById('tailor-material-select');
    if (materialSelect.value) {
        finalTags.add(materialSelect.value);
    }
    document.querySelectorAll('#tailor-style-tags-container input:checked, #tailor-general-tags-container input:checked').forEach(cb => {
        finalTags.add(cb.value);
    });
    
    // --- Calculate cost based on new pricing model ---
    let finalCost = 0;
    finalTags.forEach(tag => {
        if (tagPrices.hasOwnProperty(tag)) {
            finalCost += tagPrices[tag];
        } else if (materialTags.includes(tag)) {
            finalCost += fallbackMaterialPrice;
        } else {
            finalCost += fallbackTagPrice;
        }
    });

    craftButton.textContent = `Craft Item (${formatMoney(finalCost)})`;
    craftButton.dataset.cost = finalCost;
    craftButton.disabled = false;
}

function craftItemFromMenu() {
    const templateSelect = document.getElementById('tailor-template-select');
    const nameInput = document.getElementById('tailor-item-name');
    const selectedTemplateId = templateSelect.value;
    const craftButton = document.getElementById('craft-item-btn');
    const cost = parseFloat(craftButton.dataset.cost || '0');

    if (!selectedTemplateId) {
        showErrorNotification("Please select a template first.");
        return;
    }
    const itemName = nameInput.value.trim();
    if (!itemName) {
        showErrorNotification("Please enter a name for the item.");
        return;
    }
    if (state.money < cost) {
        showErrorNotification("You don't have enough money.");
        return;
    }

    const template = clothingTemplates[selectedTemplateId];
    const materialSelect = document.getElementById('tailor-material-select');

    // Check for material selection, if not forced
    const hasForcedMaterial = template.forcedTags && template.forcedTags.some(tag => materialTags.includes(tag));
    if (!hasForcedMaterial && !materialSelect.value) {
        showErrorNotification("Please select a material for this item.");
        return;
    }

    state.money -= cost;
    updateHeader();

    // --- Gather all final tags ---
    const finalTags = new Set(template.tags || []);
    if (template.forcedTags) {
        template.forcedTags.forEach(tag => finalTags.add(tag));
    }
    if (materialSelect.value) {
        finalTags.add(materialSelect.value);
    }
    document.querySelectorAll('#tailor-style-tags-container input:checked, #tailor-general-tags-container input:checked').forEach(cb => {
        finalTags.add(cb.value);
    });

    // --- Create a mutable copy of the covers array ---
    const finalCovers = [...template.covers];

    // --- Dynamic Coverage Logic ---
    if (finalTags.has('belly showing')) {
        const bellyIndex = finalCovers.indexOf('belly');
        if (bellyIndex > -1) {
            finalCovers.splice(bellyIndex, 1);
        }
    }

    // New rules for transparent and fetish-wear
    if (finalTags.has('transparent')) {
        finalCovers.length = 0; // Clear the array
    } else if (finalTags.has('fetish-wear')) {
        const partsToExpose = ['vagina', 'left_nipple', 'right_nipple'];
        let i = finalCovers.length;
        while (i--) {
            if (partsToExpose.includes(finalCovers[i])) {
                finalCovers.splice(i, 1);
            }
        }
    }

    const newItem = new ClothingItem({
        ...template,
        templateId: template.id, // Keep track of the original template
        id: `${template.id}_${Date.now()}`,
        name: itemName,
        tags: Array.from(finalTags),
        covers: finalCovers // Use the potentially modified covers array
    });

    state.inventory.push(newItem);
    showCraftNotification(newItem.name, template.name);

    backToTailorHub();
}

/* ==============================================================
   BOTTOM BUTTONS & OVERLAYS
   ============================================================== */
function initBottomButtons(){
  // Character / Social / Journal / Saves – placeholder handlers (you can flesh out)
  document.getElementById('btnChar'   ).onclick = () => openOverlay('btnChar');
  document.getElementById('btnSocial' ).onclick = () => openOverlay('btnSocial');
  document.getElementById('btnJournal').onclick = () => openOverlay('btnJournal');
  document.getElementById('btnSaves'  ).onclick = () => openOverlay('btnSaves');

  // Settings button – opens its overlay
  document.getElementById('btnSettings').onclick = () => openOverlay('btnSettings');

  // Cheats button – appears only after the checkbox is ticked
  document.getElementById('cheatsBtn'  ).onclick = () => openOverlay('cheatsBtn');
}

function positionCalendar() {
    const sidebar = document.getElementById('sidebar');
    const calendar = document.getElementById('calendar-overlay');
    if (sidebar && calendar) {
        const sidebarRect = sidebar.getBoundingClientRect();
        const dateRect = document.getElementById('date').getBoundingClientRect();
        calendar.style.left = `${sidebarRect.right + 10}px`; // 10px gap
        calendar.style.top = `${dateRect.top}px`;
    }
}

function initCalendar() {
  document.getElementById('date').onclick = () => {
    const calOverlay = document.getElementById('calendar-overlay');
    if (calOverlay.style.display === 'block') {
      calOverlay.style.display = 'none';
    } else {
      closeAllOverlays();
      state.calendarDate = new Date(state.currentTime);
      buildCalendar(state.calendarDate.getFullYear(), state.calendarDate.getMonth());
      positionCalendar(); // Position it dynamically
      calOverlay.style.display = 'block';
    }
  };

  document.getElementById('calendar-prev-btn').onclick = () => {
    state.calendarDate.setMonth(state.calendarDate.getMonth() - 1);
    buildCalendar(state.calendarDate.getFullYear(), state.calendarDate.getMonth());
  };

  document.getElementById('calendar-next-btn').onclick = () => {
    state.calendarDate.setMonth(state.calendarDate.getMonth() + 1);
    buildCalendar(state.calendarDate.getFullYear(), state.calendarDate.getMonth());
  };
}

/* Generic overlay toggler (click again to hide) */
function openOverlay(btnId){
  const ov = document.getElementById(`${btnId}-overlay`);
  if(!ov) return;

  if(ov.style.display === 'block'){
    ov.style.display = 'none';
  }else{
    closeAllOverlays();
    ov.style.display = 'block';

    // Populate overlays with dynamic content when they are opened
    if (btnId === 'btnSettings') {
        // Check the current font and font size radio buttons
        document.querySelectorAll(`input[name="font"][value="${state.settings.fontFamily}"]`).forEach(el => el.checked = true);
        document.querySelectorAll(`input[name="fontsize"][value="${state.settings.fontSize}"]`).forEach(el => el.checked = true);
    } else if (btnId === 'btnChar') {
        // If ui state exists, open the last tab, otherwise default to 'status'
        const lastTab = state.ui ? state.ui.lastCharTab : 'status';
        showCharTab(lastTab || 'status');
    } else if (btnId === 'btnSocial') {
        buildSocialOverlay();
    } else if (btnId === 'btnJournal') {
        buildJournalOverlay();
    } else if (btnId === 'btnSaves') {
        buildSavesOverlay();
    } else if (btnId === 'loadBtn') {
        buildLoadScreen();
    } else if (btnId === 'cheatsBtn') {
        buildCheatOverlay();
    }
  }
}

/* Hide every overlay */
function closeAllOverlays(){
  document.querySelectorAll('.overlay').forEach(o=>o.style.display='none');
}

/* --------------------------------------------------------------
   SETTINGS → CHEATS CHECKBOX
   -------------------------------------------------------------- */
function toggleCheats(cb){
  state.cheatsEnabled = cb.checked;
  applyCheatsUI();
}

function applyCheatsUI() {
  const cheatsEnabled = state.cheatsEnabled;

  const cheatsChk = document.getElementById('cheatsChk');
  if (cheatsChk) {
    cheatsChk.checked = cheatsEnabled;
  }

  if (cheatsEnabled) {
    document.body.classList.add('cheats-enabled');
  } else {
    document.body.classList.remove('cheats-enabled');
  }

  const cheatsBtn = document.getElementById('cheatsBtn');
  if (cheatsBtn) {
    cheatsBtn.style.display = cheatsEnabled ? 'inline-block' : 'none';
  }
}

/* --------------------------------------------------------------
   CHEAT OVERLAY & HELPERS
   -------------------------------------------------------------- */
function cheatModifyNpcStat(npcName, stat, amount) {
    if (state.npcs[npcName]) {
        state.npcs[npcName][stat] = Math.max(0, Math.min(100, state.npcs[npcName][stat] + amount));
        buildCheatOverlay(); // Redraw cheats to update value
        if (document.getElementById('btnSocial-overlay').style.display === 'block') {
            buildSocialOverlay();
        }
    }
}

function buildDebugCheatTab() {
    const debugTab = document.getElementById('cheat-tab-debug');
    if (!debugTab) return;

    // Helper to format a single data object (like state.pregnancy)
    const createSectionFromObject = (title, dataObject, keysToOmit = []) => {
        let content = `<h4 style="color: #00ff00; border-bottom: 1px solid #444; padding-bottom: 0.3rem; margin-top: 1rem;">${title}</h4>`;
        content += '<div style="font-family: monospace; font-size: 0.9em; white-space: pre; background: #111; padding: 0.5rem; border-radius: 4px;">';
        for (const key in dataObject) {
            if (keysToOmit.includes(key)) continue;

            const value = dataObject[key];
            let displayValue = value;
            if (typeof value === 'boolean') {
                displayValue = value ? '<span style="color: lightgreen;">true</span>' : '<span style="color: salmon;">false</span>';
            } else if (typeof value === 'object' && value !== null) {
                displayValue = JSON.stringify(value, null, 2);
            }
            content += `${key.padEnd(20)}: ${displayValue}\n`;
        }
        content += '</div>';
        return content;
    };

    // Helper to format the bodyFluids object specifically
    const createBodyFluidsSection = (title, fluidsObject) => {
        let content = `<h4 style="color: #00ff00; border-bottom: 1px solid #444; padding-bottom: 0.3rem; margin-top: 1rem;">${title}</h4>`;
        content += '<div style="font-family: monospace; font-size: 0.9em; white-space: pre; background: #111; padding: 0.5rem; border-radius: 4px;">';
        for (const location in fluidsObject) {
            if (location === 'vagina' || location === 'anus' || location === 'mouth' || location === 'body') {
                const totalVolume = fluidsObject[location].semen.reduce((acc, s) => acc + s.volume, 0);
                const fathers = [...new Set(fluidsObject[location].semen.map(s => s.fatherId))].join(', ') || 'none';
                content += `${location.padEnd(20)}: Total Volume: ${totalVolume.toFixed(2)}ml, Fathers: [${fathers}]\n`;
            }
        }
        content += '</div>';
        return content;
    };

    let html = '<div style="padding: 0 1rem;">';
    if (state.bodyFluids) {
        html += createBodyFluidsSection('Body Fluids', state.bodyFluids);
    }
    html += createSectionFromObject('Menstrual Cycle', state.menstrualCycle);
    html += createSectionFromObject('Human Pregnancy', state.pregnancy, ['eggCount']); // Omit eggCount
    html += createSectionFromObject('Parasite', state.parasite);
    html += `
        <div style="text-align: center; padding: 1rem; border-top: 1px solid #444; margin-top: 1rem;">
        </div>
    `;
    html += '</div>';

    debugTab.innerHTML = html;
}

function cheatModifyNeed(key, delta) {
  const max = state.ranges[key];
  const min = 0;
  state.needs[key] = Math.min(max, Math.max(min, state.needs[key] + delta));
  updateNeedsUI();
  buildCheatOverlay(); // Redraw cheats to update value
  checkStatTriggers();
}

// This helper function creates the new standardized row for any cheat
function createCheatControlRow(config) {
    // config: { label, value, neg_actions, pos_actions }
    return `
        <div style="display: flex; justify-content: space-between; align-items: center; padding: 0.4rem 0.2rem; border-bottom: 1px solid #333;">
            <span style="flex-basis: 30%; font-size: 0.9em;">${config.label}</span>
            <div style="flex-basis: 70%; display: flex; justify-content: flex-end; align-items: center; gap: 0.3rem;">
                <button class="overlayBtn" onclick="${config.neg_actions[0].onclick}">${config.neg_actions[0].label}</button>
                <button class="overlayBtn" onclick="${config.neg_actions[1].onclick}">${config.neg_actions[1].label}</button>
                <button class="overlayBtn" onclick="${config.neg_actions[2].onclick}">${config.neg_actions[2].label}</button>
                <span style="min-width: 6ch; text-align: center; font-weight: bold;">${config.value}</span>
                <button class="overlayBtn" onclick="${config.pos_actions[0].onclick}">${config.pos_actions[0].label}</button>
                <button class="overlayBtn" onclick="${config.pos_actions[1].onclick}">${config.pos_actions[1].label}</button>
                <button class="overlayBtn" onclick="${config.pos_actions[2].onclick}">${config.pos_actions[2].label}</button>
            </div>
        </div>
    `;
}

function showCheatTab(tabName) {
    document.querySelectorAll('.cheat-tab-content').forEach(el => el.style.display = 'none');
    document.getElementById(`cheat-tab-${tabName}`).style.display = 'block';
    if (state.ui) {
        state.ui.lastCheatTab = tabName;
    }
}

function buildCheatOverlay() {
    const body = document.querySelector('#cheatsBtn-overlay .overlayBody');
    body.innerHTML = ''; // Clear previous content

    // --- Get active tab from state ---
    const activeTab = (state.ui && state.ui.lastCheatTab) ? state.ui.lastCheatTab : 'general';

    // --- Create Tab Buttons ---
    const tabButtonContainer = document.createElement('div');
    tabButtonContainer.className = 'cheat-tabs-container';
    const tabConfigs = [
        { name: 'General', id: 'general' },
        { name: 'Skills', id: 'skills' },
        { name: 'NPCs', id: 'npcs' },
        { name: 'Body/Debug', id: 'debug' }
    ];
    tabConfigs.forEach(config => {
        const btn = document.createElement('button');
        btn.className = 'overlayBtn';
        btn.style.flexGrow = '1';
        btn.textContent = config.name;
        btn.onclick = () => showCheatTab(config.id);
        tabButtonContainer.appendChild(btn);
    });

    // --- Create Panels Container ---
    const panelsContainer = document.createElement('div');
    panelsContainer.className = 'cheat-panels-container';

    // --- Build and Append All Tabs ---

    // 1. General Tab
    const generalTab = document.createElement('div');
    generalTab.id = 'cheat-tab-general';
    generalTab.className = 'cheat-tab-content';
    let generalContent = '<div style="display: flex; gap: 2rem;">';
    let leftCol = '<div style="flex-basis: 50%;">';
    leftCol += '<h4 style="text-align: center;">Needs</h4>';
    for (const key in state.needs) {
        const max = state.ranges[key];
        leftCol += createCheatControlRow({
            label: key.charAt(0).toUpperCase() + key.slice(1),
            value: `${state.needs[key].toFixed(0)}`,
            neg_actions: [ { label: '-50%', onclick: `cheatModifyNeed('${key}', -${max*0.5})` }, { label: '-10%', onclick: `cheatModifyNeed('${key}', -${max*0.1})` }, { label: '-1%', onclick: `cheatModifyNeed('${key}', -${max*0.01})` } ],
            pos_actions: [ { label: '+1%', onclick: `cheatModifyNeed('${key}', ${max*0.01})` }, { label: '+10%', onclick: `cheatModifyNeed('${key}', ${max*0.1})` }, { label: '+50%', onclick: `cheatModifyNeed('${key}', ${max*0.5})` } ]
        });
    }
    leftCol += '</div>';
    let rightCol = '<div style="flex-basis: 50%;">';
    rightCol += '<h4 style="text-align: center;">Money & Toggles</h4>';
    rightCol += createCheatControlRow({
        label: "Money", value: `$${state.money.toFixed(2)}`,
        neg_actions: [ { label: '-1k', onclick: `cheatMoney(-1000)` }, { label: '-100', onclick: `cheatMoney(-100)` }, { label: '-10', onclick: `cheatMoney(-10)` } ],
        pos_actions: [ { label: '+10', onclick: `cheatMoney(10)` }, { label: '+100', onclick: `cheatMoney(100)` }, { label: '+1k', onclick: `cheatMoney(1000)` } ]
    });
    rightCol += `<div style="text-align: center; padding: 1rem;"><label><input type="checkbox" onchange="toggleCorruptionDisplay(this)" ${state.showCorruption?'checked':''}> Show Corruption Bar</label></div>`;
    rightCol += `<div style="text-align: center; padding: 0.5rem;"><button class="overlayBtn" onclick="toggleParasitePregnancyCheat()">Parasite Pregnancy: ${state.parasite.canImpregnate ? '<span style=\\"color: red\\">Enabled</span>' : 'Disabled'}</button></div>`;
    rightCol += '</div>';
    generalContent += leftCol + rightCol + '</div>';
    generalTab.innerHTML = generalContent;
    panelsContainer.appendChild(generalTab);

    // 2. Skills Tab
    const skillsTab = document.createElement('div');
    skillsTab.id = 'cheat-tab-skills';
    skillsTab.className = 'cheat-tab-content';
    const skillsColumnContainer = document.createElement('div');
    skillsColumnContainer.className = 'skills-column-container';
    let skillsHtml = '';
    for (const skillName in state.skills) {
        skillsHtml += createCheatControlRow({
            label: skillName, value: `${state.skills[skillName].exp.toFixed(0)} exp`,
            neg_actions: [ {label: '-64', onclick:`cheatAddSkillExp('${skillName}', -64)`}, {label: '-8', onclick:`cheatAddSkillExp('${skillName}', -8)`}, {label: '-1', onclick:`cheatAddSkillExp('${skillName}', -1)`} ],
            pos_actions: [ {label: '+1', onclick:`cheatAddSkillExp('${skillName}', 1)`}, {label: '+8', onclick:`cheatAddSkillExp('${skillName}', 8)`}, {label: '+64', onclick:`cheatAddSkillExp('${skillName}', 64)`} ],
        });
    }
    skillsColumnContainer.innerHTML = skillsHtml;
    skillsTab.appendChild(skillsColumnContainer);
    panelsContainer.appendChild(skillsTab);

    // 3. NPCs Tab
    const npcsTab = document.createElement('div');
    npcsTab.id = 'cheat-tab-npcs';
    npcsTab.className = 'cheat-tab-content';
    let npcsHtml = '<h4 style="text-align: center;">NPCs</h4><div style="display: flex; gap: 1rem;">';
    const npcs = Object.keys(state.npcs);
    const npcMid = Math.ceil(npcs.length / 2);
    const npcCol1 = npcs.slice(0, npcMid);
    const npcCol2 = npcs.slice(npcMid);
    let npcCol1Html = '<div style="flex-basis: 50%;">';
    npcCol1.forEach(npcName => {
        npcCol1Html += `<h5 style="text-align:center;">${npcName}</h5>`;
        for(const stat in state.npcs[npcName]) {
            if(typeof state.npcs[npcName][stat] === 'number') {
                npcCol1Html += createCheatControlRow({
                    label: stat.charAt(0).toUpperCase() + stat.slice(1), value: state.npcs[npcName][stat],
                    neg_actions: [ {label: '-25', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', -25)`}, {label: '-5', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', -5)`}, {label: '-1', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', -1)`} ],
                    pos_actions: [ {label: '+1', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', 1)`}, {label: '+5', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', 5)`}, {label: '+25', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', 25)`} ]
                });
            }
        }
    });
    npcCol1Html += '</div>';
    let npcCol2Html = '<div style="flex-basis: 50%;">';
    npcCol2.forEach(npcName => {
        npcCol2Html += `<h5 style="text-align:center;">${npcName}</h5>`;
        for(const stat in state.npcs[npcName]) {
            if(typeof state.npcs[npcName][stat] === 'number') {
                npcCol2Html += createCheatControlRow({
                    label: stat.charAt(0).toUpperCase() + stat.slice(1), value: state.npcs[npcName][stat],
                    neg_actions: [ {label: '-25', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', -25)`}, {label: '-5', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', -5)`}, {label: '-1', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', -1)`} ],
                    pos_actions: [ {label: '+1', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', 1)`}, {label: '+5', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', 5)`}, {label: '+25', onclick:`cheatModifyNpcStat('${npcName}', '${stat}', 25)`} ]
                });
            }
        }
    });
    npcCol2Html += '</div>';
    npcsTab.innerHTML = npcsHtml + npcCol1Html + npcCol2Html + '</div>';
    panelsContainer.appendChild(npcsTab);

    // 4. Debug Tab
    const debugTab = document.createElement('div');
    debugTab.id = 'cheat-tab-debug';
    debugTab.className = 'cheat-tab-content';
    panelsContainer.appendChild(debugTab); // Append empty, will be filled by its own function

    // Append main containers to the overlay body
    body.appendChild(tabButtonContainer);
    body.appendChild(panelsContainer);

    // Populate the debug tab content
    buildDebugCheatTab();

    // Show the correct tab
    showCheatTab(activeTab);
}

/* optional money cheat – keeps two‑decimal precision */
function cheatMoney(delta){
  state.money = Math.round((state.money + delta) * 100) / 100;
  updateHeader();
  buildCheatOverlay();
}

function toggleParasitePregnancyCheat() {
    state.parasite.canImpregnate = !state.parasite.canImpregnate;
    buildCheatOverlay(); // Re-render the cheat overlay to update the button text
}

/* toggle the hidden “Corruption” bar */
function toggleCorruptionDisplay(cb){
  state.showCorruption = cb.checked;
  updateNeedsUI();
}

/* --------------------------------------------------------------
   INITIALISATION
   -------------------------------------------------------------- */
function getHairLengthLabel(length) {
    if (length == 0) return 'shaved head';
    if (length <= 2) return 'buzzed hair';
    if (length <= 15) return 'short';
    if (length <= 30) return 'chin-length';
    if (length <= 45) return 'shoulder-length';
    if (length <= 60) return 'chest-length';
    if (length <= 80) return 'waist-length';
    return 'thigh-length';
}

const bodyPartDisplayOrder = [
    'face', 'eyes', 'lips', 'neck', 'breasts', 'nipples', 'arms', 'hands', 'belly', 'buttocks', 'vagina', 'thighs', 'calves', 'feet'
];

const descriptorGroupMap = {
    'face': { display: 'face' }, 'eye': { display: 'eyes' }, 'lips': { display: 'lips' },
    'neck': { display: 'neck' }, 'breast': { display: 'breasts' }, 'nipple': { display: 'nipples' },
    'arm': { display: 'arms' }, 'hand': { display: 'hands' }, 'belly': { display: 'belly' },
    'ass_cheek': { display: 'buttocks' }, 'vagina': { display: 'vagina' },
    'thigh': { display: 'thighs' }, 'calf': { display: 'calves' }, 'foot': { display: 'feet' }
};

function randomizeBodyDescriptors(bodyObject) {
    for (const groupName of bodyPartDisplayOrder) {
        const isFemaleOnly = femaleOnlyDescriptors.includes(groupName);
        const isMaleOnly = maleOnlyDescriptors.includes(groupName);
        if (state.sex === 'female' && isMaleOnly) continue;
        if (state.sex === 'male' && isFemaleOnly) continue;
        if (!bodyPartDescriptors[groupName]) continue;

        const descriptors = bodyPartDescriptors[groupName];
        const randomDescriptor = descriptors[Math.floor(Math.random() * descriptors.length)];

        for (const partId in bodyObject) {
            const basePartName = partId.replace(/left_|right_/, '');
            const groupInfo = descriptorGroupMap[basePartName];
            if (groupInfo && groupInfo.display === groupName) {
                bodyObject[partId].descriptor = randomDescriptor;
            }
        }
    }
}

function generateCharacterDescription(appearance, body, includeMods = false) {
    const name = "Maya";
    let age = 18; // Default age
    if (appearance.birthDate) {
        const birth = new Date(appearance.birthDate);
        age = state.currentTime.getFullYear() - birth.getFullYear();
        const m = state.currentTime.getMonth() - birth.getMonth();
        if (m < 0 || (m === 0 && state.currentTime.getDate() < birth.getDate())) {
            age--;
        }
    }

    // Helper to get a descriptor for a given group from the provided body object.
    const getDescriptor = (group, bodyObject) => {
        for (const partId in bodyObject) {
            const partInfo = bodyObject[partId];
            if (partInfo && partInfo.descriptor) {
                const basePartName = partId.replace(/left_|right_/, '');
                const groupInfo = descriptorGroupMap[basePartName];
                if (groupInfo && groupInfo.display === group) {
                    return partInfo.descriptor;
                }
            }
        }
        return ''; // Return empty string if no descriptor is found
    };

    // --- Build Paragraph 1 ---
    const hairColor = appearance.hairColor.hex;
    const hairShadowColor = getLuminance(hairColor) < 70 ? 'white' : 'black';
    const hairShadow = `0 0 9px ${hairShadowColor}`;
    const hairLengthLabel = getHairLengthLabel(appearance.hairLength);
    const hairColorName = appearance.hairColor.name.toLowerCase();
    const hairStr = `${hairLengthLabel} <span style="color: ${hairColor}; font-weight: bold; text-shadow: ${hairShadow};">${hairColorName} hair</span>`;
    let para1 = `<p><strong>${name}</strong> is an ${age}-year-old woman, standing ${appearance.height} cm tall. She has ${hairStr} and a ${appearance.skinColor.name.toLowerCase()} complexion.</p>`;

    // --- Build Paragraph 2 ---
    const eyeColor = appearance.eyeColor.hex;
    const eyeShadowColor = getLuminance(eyeColor) < 70 ? 'white' : 'black';
    const eyeShadow = `0 0 9px ${eyeShadowColor}`;
    const eyeDescriptor = getDescriptor('eyes', body);
    const eyeColorName = appearance.eyeColor.name.toLowerCase();
    const eyesStr = `${eyeDescriptor} <span style="color: ${eyeColor}; font-weight: bold; text-shadow: ${eyeShadow};">${eyeColorName} eyes</span>`;
    
    // Sentence parts - fetch all descriptors first
    const faceDesc = getDescriptor('face', body);
    const lipsDesc = getDescriptor('lips', body);
    const breastsDesc = getDescriptor('breasts', body);
    const nipplesDesc = getDescriptor('nipples', body);
    const bellyDesc = getDescriptor('belly', body);
    const buttocksDesc = getDescriptor('buttocks', body);
    const vaginaDesc = getDescriptor('vagina', body);
    const armsDesc = getDescriptor('arms', body);
    const handsDesc = getDescriptor('hands', body);
    const thighsDesc = getDescriptor('thighs', body);
    const calvesDesc = getDescriptor('calves', body);
    const feetDesc = getDescriptor('feet', body);

    // Assemble sentences, only including parts that have descriptors
    const faceParts = [];
    if (faceDesc) faceParts.push(`a ${faceDesc} face`);
    if (eyeDescriptor) faceParts.push(`with ${eyesStr}`);
    if (lipsDesc) faceParts.push(`and ${lipsDesc} lips`);
    
    const bodyParts = [];
    if (breastsDesc) bodyParts.push(`${breastsDesc} breasts`);
    if (nipplesDesc) bodyParts.push(`with ${nipplesDesc} nipples`);
    if (bellyDesc) bodyParts.push(`a ${bellyDesc} belly`);
    if (buttocksDesc) bodyParts.push(`${buttocksDesc} buttocks`);
    if (vaginaDesc) bodyParts.push(`and a ${vaginaDesc} vagina`);

    const limbsParts = [];
    if (armsDesc) limbsParts.push(`She has ${armsDesc} arms`);
    if (handsDesc) limbsParts.push(`with ${handsDesc} hands`);
    if (thighsDesc) limbsParts.push(`her thighs are ${thighsDesc}`);
    if (calvesDesc) limbsParts.push(`with ${calvesDesc} calves`);
    if (feetDesc) limbsParts.push(`and ${feetDesc} feet`);

    let para2 = `<p>She has ${faceParts.join(' ')}.`;
    if (bodyParts.length > 0) para2 += ` Her body has ${bodyParts.join(', ').replace(/, and/g, ' and')}.`;
    if (limbsParts.length > 0) para2 += ` ${limbsParts.join(', ').replace(/, her/g, ' her').replace(/, with/g, ' with').replace(/, and/g, ' and')}.`;
    para2 += `</p>`;

    // --- Build Paragraph 3 (Tattoos & Piercings) ---
    let para3 = '';
    if (includeMods) {
        const coverageMap = getCoverageInfo();
        const visibleTattoos = [];
        const visiblePiercings = [];

        for (const partId in body) {
            const part = body[partId];
            // A part is visible if it's NOT in the coverage map
            if (!coverageMap.has(partId)) {
                if (part.tattoos && part.tattoos.length > 0) {
                    part.tattoos.forEach(tattoo => {
                        visibleTattoos.push(`on her ${part.name.toLowerCase()} is ${tattoo.design}`);
                    });
                }
                if (part.piercings && part.piercings.length > 0) {
                    part.piercings.forEach(piercing => {
                        visiblePiercings.push(`her ${part.name.toLowerCase()} is pierced with ${piercing.jewelry}`);
                    });
                }
            }
        }

        if (visibleTattoos.length > 0) {
            para3 += `<p>Visible tattoos include: ${visibleTattoos.join(', ')}.</p>`;
        }
        if (visiblePiercings.length > 0) {
            // If there's no tattoo paragraph, start a new one. Otherwise, add to the existing one.
            if (para3 === '') {
                para3 += `<p>She has several piercings: ${visiblePiercings.join(', ')}.</p>`;
            } else {
                para3 = para3.slice(0, -4); // remove last </p>
                para3 += ` She also has several piercings: ${visiblePiercings.join(', ')}.</p>`;
            }
        }
    }

    return para1 + para2 + para3;
}

function applyBodyDescriptorsFromUI(bodyObject) {
    const descriptorSelects = document.querySelectorAll('#bodyShapeOptions select');
    descriptorSelects.forEach(select => {
        const group = select.dataset.partGroup;
        const descriptor = select.value;
        
        for (const partId in bodyObject) {
            const basePartName = partId.replace(/left_|right_/, '');
            const groupInfo = descriptorGroupMap[basePartName];
            if (groupInfo && groupInfo.display === group) {
                bodyObject[partId].descriptor = descriptor;
            }
        }
    });
}

function updateCreationPreview() {
    const previewContainer = document.getElementById('creation-preview');
    if (!previewContainer) return;

    // Build a temporary appearance object from the current UI values for the preview
    const tempAppearance = {
        birthDate: state.appearance.birthDate,
        height: parseInt(document.getElementById('heightSlider').value, 10),
        hairLength: parseInt(document.getElementById('hairLengthSlider').value, 10),
        skinColor: { name: document.querySelector('#skin-color-picker .color-swatch.selected')?.dataset.colorName || state.appearance.skinColor.name, hex: document.querySelector('#skin-color-picker .color-swatch.selected')?.dataset.colorHex || state.appearance.skinColor.hex },
        hairColor: state.appearance.hairColor, // This is updated directly from the picker
        eyeColor: state.appearance.eyeColor,   // This is updated directly from the picker
    };

    // Build a temporary body object for the preview and apply descriptors
    const tempBody = createPlayerBody(state.sex);
    applyBodyDescriptorsFromUI(tempBody);

    previewContainer.innerHTML = `<h4>Preview</h4>` + generateCharacterDescription(tempAppearance, tempBody, true);
}

function populateSkinPicker(containerId, paletteName, targetProperty) {
    const palette = colorPalettes[paletteName];
    const container = document.getElementById(containerId);
    if (!container) return;

    container.innerHTML = ''; // Clear previous content
    container.className = 'grid-picker-container'; // Use grid styles

    for (const groupName in palette) {
        const colors = palette[groupName];
        const row = document.createElement('div');
        row.className = 'grid-picker-row';

        colors.forEach(hex => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch'; // Use the circular swatch style
            swatch.style.backgroundColor = hex;
            swatch.dataset.colorName = groupName;
            swatch.dataset.colorHex = hex;
            swatch.title = `${groupName} (${hex})`;

            swatch.onclick = () => {
                container.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                swatch.classList.add('selected');
                state.appearance[targetProperty] = { name: groupName, hex: hex };
                updateCreationPreview();
            };
            row.appendChild(swatch);
        });
        container.appendChild(row);
    }

    // Set default selection for skin
    const currentHex = state.appearance[targetProperty].hex;
    const defaultSwatch = Array.from(container.querySelectorAll('.color-swatch')).find(s => s.dataset.colorHex === currentHex);
    if (defaultSwatch) {
        defaultSwatch.classList.add('selected');
    } else if (container.querySelector('.color-swatch')) {
        const firstSwatch = container.querySelector('.color-swatch');
        firstSwatch.classList.add('selected');
        state.appearance[targetProperty] = { name: firstSwatch.dataset.colorName, hex: firstSwatch.dataset.colorHex };
        updateCreationPreview();
    }
}

function showGrayscaleOverlay(event, targetProperty) {
    const overlay = document.getElementById('grayscale-overlay');
    const container = document.getElementById('grayscale-picker-container');
    if (!overlay || !container) return;

    container.innerHTML = ''; // Clear previous content

    const grays = [
        { name: 'Gray', hex: '#D5D5D5' }, { name: 'Gray', hex: '#AAAAAA' },
        { name: 'Gray', hex: '#808080' }, { name: 'Gray', hex: '#555555' },
        { name: 'Gray', hex: '#2A2A2A' }, { name: 'Black', hex: '#000000' }
    ];
    const white = { name: 'White', hex: '#FFFFFF' };
    const shape = [2, 3, 2];
    let grayIndex = 0;
    let swatchIndex = 0;

    shape.forEach(itemsThisRow => {
        const row = document.createElement('div');
        row.className = 'hex-row';
        for (let i = 0; i < itemsThisRow; i++) {
            let color;
            // The 4th swatch (index 3) is the center one
            if (swatchIndex === 3) {
                color = white;
            } else {
                color = grays[grayIndex++];
            }
            
            const swatch = document.createElement('div');
            swatch.className = 'hex-swatch';
            swatch.style.backgroundColor = color.hex;
            swatch.dataset.colorName = color.name;
            swatch.dataset.colorHex = color.hex;
            swatch.title = `${color.name} (${color.hex})`;

            // Standard selection logic
            swatch.onclick = () => {
                state.appearance[targetProperty] = { name: color.name, hex: color.hex };
                const mainPickerContainer = document.getElementById(`${targetProperty.replace('Color', '-color-picker')}`);
                if (mainPickerContainer) {
                    mainPickerContainer.querySelectorAll('.hex-swatch').forEach(s => s.classList.remove('selected'));
                    const newSelection = Array.from(mainPickerContainer.querySelectorAll('.hex-swatch')).find(s => s.dataset.colorHex === color.hex);
                    if (newSelection) {
                        newSelection.classList.add('selected');
                    } else {
                        // If the color is not in the main palette (like a gray), select the center white swatch as a visual indicator
                        mainPickerContainer.querySelector('.hex-swatch[title^="Grays"]').classList.add('selected');
                    }
                }
                updateCreationPreview();
                overlay.style.display = 'none';
            };
            row.appendChild(swatch);
            swatchIndex++;
        }
        container.appendChild(row);
    });

    // --- Dynamic Positioning ---
    // 1. Make the overlay part of the layout but invisible to measure it
    overlay.style.visibility = 'hidden';
    overlay.style.display = 'block';

    // 2. Get dimensions and calculate position
    const swatchRect = event.target.getBoundingClientRect();
    const overlayRect = overlay.getBoundingClientRect();
    const top = swatchRect.top + (swatchRect.height / 2) - (overlayRect.height / 2);
    const left = swatchRect.left + (swatchRect.width / 2) - (overlayRect.width / 2);

    // 3. Apply position and make it visible
    overlay.style.top = `${top}px`;
    overlay.style.left = `${left}px`;
    overlay.style.transform = 'none'; // Override the default centering transform
    overlay.style.visibility = 'visible';

    // --- Add listener to close on outside click ---
    const closeListener = (closeEvent) => {
        if (!overlay.contains(closeEvent.target)) {
            overlay.style.display = 'none';
            document.removeEventListener('click', closeListener);
        }
    };
    // Use a timeout to add the listener, preventing it from catching the same click that opened it
    setTimeout(() => {
        document.addEventListener('click', closeListener);
    }, 0);
}

function populateHexPicker(containerId, paletteName, targetProperty) {
    const useUnnatural = document.getElementById('unnaturalColorsToggle').checked;
    const palette = useUnnatural ? colorPalettes[paletteName].unnatural : colorPalettes[paletteName].natural;
    const container = document.getElementById(containerId);
    if (!container) return;

    container.innerHTML = ''; // Clear previous content
    container.className = 'hex-picker-container';
    let allColors = Array.isArray(palette) ? palette : [];

    // 2. Create the specific honeycomb shape
    const shape = [6, 7, 8, 9, 10, 11, 10, 9, 8, 7, 6]; // New 11-row, 91-slot shape
    let colorIndex = 0;

    shape.forEach(itemsThisRow => {
        if (colorIndex >= allColors.length) return;

        const row = document.createElement('div');
        row.className = 'hex-row';
        
        for (let i = 0; i < itemsThisRow && colorIndex < allColors.length; i++) {
            const color = allColors[colorIndex];
            
            const swatch = document.createElement('div');
            swatch.className = 'hex-swatch';
            swatch.style.backgroundColor = color.hex;
            swatch.dataset.colorName = color.name;
            swatch.dataset.colorHex = color.hex;
            swatch.title = `${color.name} (${color.hex})`;

            // If this is the special "Grays..." swatch, give it the overlay-opening function.
            // Otherwise, give it the standard color selection function.
            if (color.name === 'Grays...') {
                swatch.onclick = (event) => showGrayscaleOverlay(event, targetProperty);
            } else {
                swatch.onclick = () => {
                    container.querySelectorAll('.hex-swatch').forEach(s => s.classList.remove('selected'));
                    swatch.classList.add('selected');
                    state.appearance[targetProperty] = { name: color.name, hex: color.hex };
                    updateCreationPreview();
                };
            }

            row.appendChild(swatch);
            colorIndex++;
        }
        
        container.appendChild(row);
    });

    // 3. Set the default selection
    const currentHex = state.appearance[targetProperty].hex;
    const defaultSwatch = Array.from(container.querySelectorAll('.hex-swatch')).find(s => s.dataset.colorHex === currentHex);
    if (defaultSwatch) {
        defaultSwatch.classList.add('selected');
    } else if (container.querySelector('.hex-swatch')) {
        const firstSwatch = container.querySelector('.hex-swatch');
        firstSwatch.classList.add('selected');
        state.appearance[targetProperty] = { 
            name: firstSwatch.dataset.colorName, 
            hex: firstSwatch.dataset.colorHex 
        };
        updateCreationPreview();
    }
}

function initCreationScreen() {
    // --- Randomize all values ---
    state.appearance.height = 150 + Math.floor(Math.random() * 36); // 150-185
    state.appearance.hairLength = Math.floor(Math.random() * 101); // 0-100

    const skinPalette = colorPalettes.skin;
    const skinGroups = Object.keys(skinPalette);
    const randomSkinGroup = skinGroups[Math.floor(Math.random() * skinGroups.length)];
    const randomSkinColors = skinPalette[randomSkinGroup];
    const randomSkinHex = randomSkinColors[Math.floor(Math.random() * randomSkinColors.length)];
    state.appearance.skinColor = { name: randomSkinGroup, hex: randomSkinHex };

    const naturalHairPalette = colorPalettes.hair.natural;
    state.appearance.hairColor = naturalHairPalette[Math.floor(Math.random() * naturalHairPalette.length)];

    const naturalEyePalette = colorPalettes.eyes.natural;
    state.appearance.eyeColor = naturalEyePalette[Math.floor(Math.random() * naturalEyePalette.length)];

    // --- Populate UI elements ---
    populateSkinPicker('skin-color-picker', 'skin', 'skinColor');

    const heightSlider = document.getElementById('heightSlider');
    const heightValue = document.getElementById('heightValue');
    heightSlider.value = state.appearance.height;
    heightValue.textContent = state.appearance.height;
    heightSlider.oninput = (e) => {
        heightValue.textContent = e.target.value;
        updateCreationPreview();
    };

    const hairLengthSlider = document.getElementById('hairLengthSlider');
    const hairLengthValue = document.getElementById('hairLengthValue');
    hairLengthSlider.value = state.appearance.hairLength;
    hairLengthValue.textContent = state.appearance.hairLength;
    hairLengthSlider.oninput = (e) => {
        hairLengthValue.textContent = e.target.value;
        updateCreationPreview();
    };

    // Populate Body Shape Descriptor Dropdowns and randomize them
    const bodyShapeContainer = document.getElementById('bodyShapeOptions');
    bodyShapeContainer.innerHTML = '';
    const bodyPartDisplayOrder = [
        'face', 'eyes', 'lips', 'neck', 'breasts', 'nipples', 'arms', 'hands', 'belly', 'buttocks', 'vagina', 'thighs', 'calves', 'feet'
    ];
    for (const groupName of bodyPartDisplayOrder) {
        const isFemaleOnly = femaleOnlyDescriptors.includes(groupName);
        const isMaleOnly = maleOnlyDescriptors.includes(groupName);
        if (state.sex === 'female' && isMaleOnly) continue;
        if (state.sex === 'male' && isFemaleOnly) continue;
        if (!bodyPartDescriptors[groupName]) continue;

        const descriptors = bodyPartDescriptors[groupName];
        const controlWrapper = document.createElement('div');
        const label = document.createElement('label');
        label.textContent = groupName.charAt(0).toUpperCase() + groupName.slice(1);
        label.style.display = 'block';
        label.style.marginBottom = '0.25rem';
        
        const select = document.createElement('select');
        select.dataset.partGroup = groupName;
        select.style.width = '100%';
        select.onchange = updateCreationPreview;

        descriptors.forEach(desc => {
            const option = document.createElement('option');
            option.value = desc;
            option.textContent = desc.charAt(0).toUpperCase() + desc.slice(1);
            select.appendChild(option);
        });
        
        // Randomize selection
        select.selectedIndex = Math.floor(Math.random() * select.options.length);

        controlWrapper.appendChild(label);
        controlWrapper.appendChild(select);
        bodyShapeContainer.appendChild(controlWrapper);
    }

    // Populate color pickers
    populateHexPicker('hair-color-picker', 'hair', 'hairColor');
    populateHexPicker('eye-color-picker', 'eyes', 'eyeColor');

    // Add listener for the unnatural colors toggle
    const unnaturalToggle = document.getElementById('unnaturalColorsToggle');
    unnaturalToggle.onchange = () => {
        populateHexPicker('hair-color-picker', 'hair', 'hairColor');
        populateHexPicker('eye-color-picker', 'eyes', 'eyeColor');
        updateCreationPreview(); // Update preview after palette changes
    };

    // Initial call to populate the preview pane with all randomized values
    updateCreationPreview();
}

function finalizeCharacterFromUI() {
    // --- Step 1: Gather all UI data and update appearance state ---
    const heightSlider = document.getElementById('heightSlider');
    const hairLengthSlider = document.getElementById('hairLengthSlider');
    const selectedSkinSwatch = document.querySelector('#skin-color-picker .color-swatch.selected');

    state.appearance.height = parseInt(heightSlider.value, 10);
    state.appearance.hairLength = parseInt(hairLengthSlider.value, 10);
    if (selectedSkinSwatch) {
        state.appearance.skinColor = {
            name: selectedSkinSwatch.dataset.colorName,
            hex: selectedSkinSwatch.dataset.colorHex
        };
    }
    // Note: hair/eye color are already handled by their own event listeners and set in state directly.

    // --- Step 2: Create the base player body object ---
    state.playerBody = createPlayerBody(state.sex);

    // --- Step 3: Apply the body descriptors to the newly created body ---
    applyBodyDescriptorsFromUI(state.playerBody);
}

function quickStartDebug() {
    initCreationScreen(); // This randomizes the UI
    finalizeCharacterFromUI(); // This reads the randomized UI into the state
    startGame({ initialMoney: 250000, skipIntro: true });
}

function startGame(options = {}) {
    const { initialMoney = 0.00, skipIntro = false } = options;

    initMenstrualCycle();
    switchScreen('gameScreen');

    state.money = initialMoney;
    if (skipIntro) {
        for (const npcName in state.npcs) {
            state.npcs[npcName].hidden = false;
        }
    }

    // UI updates
    updateHeader();
    updateNeedsUI();
    initBottomButtons();
    initCalendar();
    buildCheatOverlay();
    applySettings();
    applyCheatsUI();

    // Equip starting gear
    const startingGear = [
        'upper_bra', 'lower_panties', 'upper_tshirt', 'lower_jeans', 'feet_sneakers'
    ];
    state.inventory = startingGear.map(templateId => {
        const template = clothingTemplates[templateId];
        return new ClothingItem({
            ...template,
            templateId: template.id,
            name: `Plain ${template.name}`,
            id: `${template.id}_${Date.now()}_${Math.random()}`
        });
    });
    const bra = state.inventory.find(i => i.name === 'Plain Bra');
    if (bra) equipItem(bra.id, 'skin');
    const panties = state.inventory.find(i => i.name === 'Plain Panties');
    if (panties) equipItem(panties.id, 'skin');
    const tshirt = state.inventory.find(i => i.name === 'Plain T-shirt');
    if (tshirt) equipItem(tshirt.id, 'middle');
    const jeans = state.inventory.find(i => i.name === 'Plain Jeans');
    if (jeans) equipItem(jeans.id, 'middle');
    const sneakers = state.inventory.find(i => i.name === 'Plain Sneakers');
    if (sneakers) equipItem(sneakers.id, 'outer');
    
    updateCharDesc();

    if (skipIntro) {
        state.storyEventActive = false;
        goToScene('foyer', 30);
    } else {
        state.storyEventActive = true;
        showCurrentEvent();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    processClothingRules(); // Process all template rules once on load

    const startBtn = document.getElementById('startBtn');
    if (startBtn) {
        startBtn.addEventListener('click', () => {
            initCreationScreen();
            switchScreen('creationScreen');
        });
    }

    const loadBtn = document.getElementById('loadBtn');
    if (loadBtn) {
        loadBtn.addEventListener('click', () => openOverlay('loadBtn'));
    }

    const quickStartBtn = document.getElementById('quickStartBtn');
    if (quickStartBtn) {
        quickStartBtn.addEventListener('click', quickStartDebug);
    }

    const finalizeBtn = document.getElementById('finalizeBtn');
    if(finalizeBtn) {
        finalizeBtn.addEventListener('click', () => {
            finalizeCharacterFromUI();
            startGame();
        });
    }

    // Global Escape key handler
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            const subOverlay = document.getElementById('sub-overlay');
            if (subOverlay && subOverlay.style.display === 'block') {
                subOverlay.style.display = 'none';
                return; // Prioritize closing the sub-overlay
            }

            const calOverlay = document.getElementById('calendar-overlay');
            if (calOverlay && calOverlay.style.display === 'block') {
                calOverlay.style.display = 'none';
                return; // Close calendar and we're done
            }

            // If no sub-overlay is open, close any main overlay
            const anyOverlayOpen = document.querySelector('.overlay[style*="display: block"]');
            if (anyOverlayOpen) {
                closeAllOverlays();
            }
        }
    });

    // Global click handler to close tooltips
    document.addEventListener('click', (e) => {
        const subOverlay = document.getElementById('sub-overlay');
        if (subOverlay && subOverlay.style.display === 'block') {
            // Check if the click was outside the sub-overlay
            if (!subOverlay.contains(e.target)) {
                subOverlay.style.display = 'none';
            }
        }
    });
});

</script>
</body>
</html>
